From bd50babc9155f96a82840367c3829543a4afbc19 Mon Sep 17 00:00:00 2001
From: Bryan Gantt <dragonzkiller@gmail.com>
Date: Sat, 29 Sep 2012 23:35:20 -0500
Subject: [PATCH 1/2] wrap LegacyCamera into Gallery2 (2/2)

-remove LegacyCamera makefiles
-move panorama to com.android.camera
-change preference xmls to match with gallery package name

Change-Id: I107d8820975c2259e26f003420149106d4ebcf57
---
 Android.mk                                         |   22 -
 AndroidManifest.xml                                |   77 --
 CleanSpec.mk                                       |   52 -
 jni/feature_mos_jni.cpp                            |   22 +-
 jni/mosaic_renderer_jni.cpp                        |   28 +-
 proguard.flags                                     |   19 -
 res/layout-sw600dp/pano_capture.xml                |    4 +-
 res/layout-sw600dp/pano_review.xml                 |    2 +-
 res/layout/pano_capture.xml                        |    4 +-
 res/layout/pano_review.xml                         |    2 +-
 res/xml/camera_preferences.xml                     |    2 +-
 res/xml/video_preferences.xml                      |    2 +-
 src/com/android/camera/MenuHelper.java             |    2 +-
 src/com/android/camera/Mosaic.java                 |  206 ++++
 src/com/android/camera/MosaicFrameProcessor.java   |  237 ++++
 src/com/android/camera/MosaicRenderer.java         |   89 ++
 .../android/camera/MosaicRendererSurfaceView.java  |  374 +++++++
 .../camera/MosaicRendererSurfaceViewRenderer.java  |   83 ++
 src/com/android/camera/PanoProgressBar.java        |  185 ++++
 src/com/android/camera/PanoUtil.java               |   86 ++
 src/com/android/camera/PanoramaActivity.java       | 1170 ++++++++++++++++++++
 src/com/android/camera/panorama/Mosaic.java        |  206 ----
 .../camera/panorama/MosaicFrameProcessor.java      |  237 ----
 .../android/camera/panorama/MosaicRenderer.java    |   89 --
 .../camera/panorama/MosaicRendererSurfaceView.java |  374 -------
 .../MosaicRendererSurfaceViewRenderer.java         |   83 --
 .../android/camera/panorama/PanoProgressBar.java   |  185 ----
 src/com/android/camera/panorama/PanoUtil.java      |   86 --
 .../android/camera/panorama/PanoramaActivity.java  | 1170 --------------------
 29 files changed, 2464 insertions(+), 2634 deletions(-)
 delete mode 100644 Android.mk
 delete mode 100644 AndroidManifest.xml
 delete mode 100644 CleanSpec.mk
 delete mode 100644 proguard.flags
 create mode 100644 src/com/android/camera/Mosaic.java
 create mode 100644 src/com/android/camera/MosaicFrameProcessor.java
 create mode 100644 src/com/android/camera/MosaicRenderer.java
 create mode 100644 src/com/android/camera/MosaicRendererSurfaceView.java
 create mode 100755 src/com/android/camera/MosaicRendererSurfaceViewRenderer.java
 create mode 100644 src/com/android/camera/PanoProgressBar.java
 create mode 100644 src/com/android/camera/PanoUtil.java
 create mode 100755 src/com/android/camera/PanoramaActivity.java
 delete mode 100644 src/com/android/camera/panorama/Mosaic.java
 delete mode 100644 src/com/android/camera/panorama/MosaicFrameProcessor.java
 delete mode 100644 src/com/android/camera/panorama/MosaicRenderer.java
 delete mode 100644 src/com/android/camera/panorama/MosaicRendererSurfaceView.java
 delete mode 100755 src/com/android/camera/panorama/MosaicRendererSurfaceViewRenderer.java
 delete mode 100644 src/com/android/camera/panorama/PanoProgressBar.java
 delete mode 100644 src/com/android/camera/panorama/PanoUtil.java
 delete mode 100755 src/com/android/camera/panorama/PanoramaActivity.java

diff --git a/Android.mk b/Android.mk
deleted file mode 100644
index ec46e82..0000000
--- a/Android.mk
+++ /dev/null
@@ -1,22 +0,0 @@
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_MODULE_TAGS := optional
-
-LOCAL_SRC_FILES := $(call all-java-files-under, src)
-
-LOCAL_PACKAGE_NAME := LegacyCamera
-#LOCAL_SDK_VERSION := current
-
-LOCAL_JNI_SHARED_LIBRARIES := libjni_legacymosaic
-
-LOCAL_REQUIRED_MODULES := libjni_legacymosaic
-
-LOCAL_PROGUARD_FLAG_FILES := proguard.flags
-
-include $(BUILD_PACKAGE)
-
-ifeq ($(strip $(LOCAL_PACKAGE_OVERRIDES)),)
-# Use the following include to make our test apk.
-include $(call all-makefiles-under, $(LOCAL_PATH))
-endif
diff --git a/AndroidManifest.xml b/AndroidManifest.xml
deleted file mode 100644
index ee57c31..0000000
--- a/AndroidManifest.xml
+++ /dev/null
@@ -1,77 +0,0 @@
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-        package="com.android.camera"
-        android:versionCode="1"
-        android:versionName="1"
-        >
-
-    <original-package android:name="com.android.camera" />
-
-    <uses-permission android:name="android.permission.CAMERA" />
-    <uses-feature android:name="android.hardware.camera" />
-    <uses-feature android:name="android.hardware.camera.autofocus" android:required="false" />
-
-    <uses-permission android:name="android.permission.RECORD_AUDIO" />
-    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
-    <uses-permission android:name="android.permission.WAKE_LOCK" />
-    <uses-permission android:name="android.permission.SET_WALLPAPER" />
-    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
-    <uses-permission android:name="android.permission.READ_SMS" />
-
-    <application android:icon="@mipmap/ic_launcher_camera"
-            android:name="com.android.camera.CameraAppImpl"
-            android:label="@string/camera_label"
-            android:theme="@style/ThemeCamera"
-            android:hardwareAccelerated="true">
-        <uses-library android:name="com.google.android.media.effects" android:required="false" />
-        <receiver android:name="com.android.camera.CameraButtonIntentReceiver">
-            <intent-filter>
-                <action android:name="android.intent.action.CAMERA_BUTTON"/>
-            </intent-filter>
-        </receiver>
-        <activity android:name="com.android.camera.Camera"
-                android:configChanges="orientation|screenSize|keyboardHidden"
-                android:clearTaskOnLaunch="true"
-                android:windowSoftInputMode="stateAlwaysHidden|adjustPan">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-                <category android:name="android.intent.category.DEFAULT" />
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-            <intent-filter>
-                <action android:name="android.media.action.IMAGE_CAPTURE" />
-                <category android:name="android.intent.category.DEFAULT" />
-            </intent-filter>
-            <intent-filter>
-                <action android:name="android.media.action.STILL_IMAGE_CAMERA" />
-                <category android:name="android.intent.category.DEFAULT" />
-            </intent-filter>
-        </activity>
-        <activity android:name="com.android.camera.VideoCamera"
-                android:label="@string/video_camera_label"
-                android:configChanges="orientation|screenSize|keyboardHidden"
-                android:icon="@mipmap/ic_launcher_video_camera"
-                android:clearTaskOnLaunch="true"
-                android:windowSoftInputMode="stateAlwaysHidden|adjustPan">
-            <intent-filter>
-                <action android:name="android.media.action.VIDEO_CAMERA" />
-                <category android:name="android.intent.category.DEFAULT" />
-            </intent-filter>
-            <intent-filter>
-                <action android:name="android.media.action.VIDEO_CAPTURE" />
-                <category android:name="android.intent.category.DEFAULT" />
-            </intent-filter>
-        </activity>
-        <!-- Suppose users enter panorama from launcher, turn off the screen,
-             turn on the screen, and enter the camera from the lock screen.
-             They can switch to panorama from there. Use singleTask so there
-             will be only one panorama activity. -->
-        <activity android:name="com.android.camera.panorama.PanoramaActivity"
-                android:label="@string/pano_dialog_title"
-                android:configChanges="orientation|screenSize|keyboardHidden"
-                android:clearTaskOnLaunch="true"
-                android:windowSoftInputMode="stateAlwaysHidden|adjustPan"
-                android:launchMode="singleTask">
-        </activity>
-    </application>
-</manifest>
-
diff --git a/CleanSpec.mk b/CleanSpec.mk
deleted file mode 100644
index 1cf8763..0000000
--- a/CleanSpec.mk
+++ /dev/null
@@ -1,52 +0,0 @@
-# Copyright (C) 2007 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-# If you don't need to do a full clean build but would like to touch
-# a file or delete some intermediate files, add a clean step to the end
-# of the list.  These steps will only be run once, if they haven't been
-# run before.
-#
-# E.g.:
-#     $(call add-clean-step, touch -c external/sqlite/sqlite3.h)
-#     $(call add-clean-step, rm -rf $(PRODUCT_OUT)/obj/STATIC_LIBRARIES/libz_intermediates)
-#
-# Always use "touch -c" and "rm -f" or "rm -rf" to gracefully deal with
-# files that are missing or have been moved.
-#
-# Use $(PRODUCT_OUT) to get to the "out/target/product/blah/" directory.
-# Use $(OUT_DIR) to refer to the "out" directory.
-#
-# If you need to re-do something that's already mentioned, just copy
-# the command and add it to the bottom of the list.  E.g., if a change
-# that you made last week required touching a file and a change you
-# made today requires touching the same file, just copy the old
-# touch step and add it to the end of the list.
-#
-# ************************************************
-# NEWER CLEAN STEPS MUST BE AT THE END OF THE LIST
-# ************************************************
-
-# For example:
-#$(call add-clean-step, rm -rf $(OUT_DIR)/target/common/obj/APPS/AndroidTests_intermediates)
-#$(call add-clean-step, rm -rf $(OUT_DIR)/target/common/obj/JAVA_LIBRARIES/core_intermediates)
-#$(call add-clean-step, find $(OUT_DIR) -type f -name "IGTalkSession*" -print0 | xargs -0 rm -f)
-#$(call add-clean-step, rm -rf $(PRODUCT_OUT)/data/*)
-$(call add-clean-step, rm -rf $(PRODUCT_OUT)/obj/APPS/Camera*)
-$(call add-clean-step, rm -rf $(OUT_DIR)/target/common/obj/APPS/Camera*)
-$(call add-clean-step, rm -rf $(OUT_DIR)/target/common/obj/APPS/Camera*)
-
-# ************************************************
-# NEWER CLEAN STEPS MUST BE AT THE END OF THE LIST
-# ************************************************
diff --git a/jni/feature_mos_jni.cpp b/jni/feature_mos_jni.cpp
index 4c08257..8ec21d4 100644
--- a/jni/feature_mos_jni.cpp
+++ b/jni/feature_mos_jni.cpp
@@ -274,7 +274,7 @@ void YUV420toYVU24_NEW(ImageType yvu24, ImageType yuv420sp, int width,
 }
 
 
-JNIEXPORT void JNICALL Java_com_android_camera_panorama_Mosaic_allocateMosaicMemory(
+JNIEXPORT void JNICALL Java_com_android_camera_Mosaic_allocateMosaicMemory(
         JNIEnv* env, jobject thiz, jint width, jint height)
 {
     tWidth[HR] = width;
@@ -293,7 +293,7 @@ JNIEXPORT void JNICALL Java_com_android_camera_panorama_Mosaic_allocateMosaicMem
     AllocateTextureMemory(tWidth[HR], tHeight[HR], tWidth[LR], tHeight[LR]);
 }
 
-JNIEXPORT void JNICALL Java_com_android_camera_panorama_Mosaic_freeMosaicMemory(
+JNIEXPORT void JNICALL Java_com_android_camera_Mosaic_freeMosaicMemory(
         JNIEnv* env, jobject thiz)
 {
     for(int i = 0; i < MAX_FRAMES; i++)
@@ -383,7 +383,7 @@ void ConvertYVUAiToPlanarYVU(unsigned char *planar, unsigned char *in, int width
     }
 }
 
-JNIEXPORT jfloatArray JNICALL Java_com_android_camera_panorama_Mosaic_setSourceImageFromGPU(
+JNIEXPORT jfloatArray JNICALL Java_com_android_camera_Mosaic_setSourceImageFromGPU(
         JNIEnv* env, jobject thiz)
 {
     double  t0, t1, time_c;
@@ -435,7 +435,7 @@ JNIEXPORT jfloatArray JNICALL Java_com_android_camera_panorama_Mosaic_setSourceI
 
 
 
-JNIEXPORT jfloatArray JNICALL Java_com_android_camera_panorama_Mosaic_setSourceImage(
+JNIEXPORT jfloatArray JNICALL Java_com_android_camera_Mosaic_setSourceImage(
         JNIEnv* env, jobject thiz, jbyteArray photo_data)
 {
     double  t0, t1, time_c;
@@ -492,19 +492,19 @@ JNIEXPORT jfloatArray JNICALL Java_com_android_camera_panorama_Mosaic_setSourceI
     return bytes;
 }
 
-JNIEXPORT void JNICALL Java_com_android_camera_panorama_Mosaic_setBlendingType(
+JNIEXPORT void JNICALL Java_com_android_camera_Mosaic_setBlendingType(
         JNIEnv* env, jobject thiz, jint type)
 {
     blendingType = int(type);
 }
 
-JNIEXPORT void JNICALL Java_com_android_camera_panorama_Mosaic_setStripType(
+JNIEXPORT void JNICALL Java_com_android_camera_Mosaic_setStripType(
         JNIEnv* env, jobject thiz, jint type)
 {
     stripType = int(type);
 }
 
-JNIEXPORT void JNICALL Java_com_android_camera_panorama_Mosaic_reset(
+JNIEXPORT void JNICALL Java_com_android_camera_Mosaic_reset(
         JNIEnv* env, jobject thiz)
 {
     frame_number_HR = 0;
@@ -519,7 +519,7 @@ JNIEXPORT void JNICALL Java_com_android_camera_panorama_Mosaic_reset(
     Init(LR,MAX_FRAMES);
 }
 
-JNIEXPORT jint JNICALL Java_com_android_camera_panorama_Mosaic_reportProgress(
+JNIEXPORT jint JNICALL Java_com_android_camera_Mosaic_reportProgress(
         JNIEnv* env, jobject thiz, jboolean hires, jboolean cancel_computation)
 {
     if(bool(hires))
@@ -533,7 +533,7 @@ JNIEXPORT jint JNICALL Java_com_android_camera_panorama_Mosaic_reportProgress(
         return (jint) gProgress[LR];
 }
 
-JNIEXPORT jint JNICALL Java_com_android_camera_panorama_Mosaic_createMosaic(
+JNIEXPORT jint JNICALL Java_com_android_camera_Mosaic_createMosaic(
         JNIEnv* env, jobject thiz, jboolean value)
 {
     high_res = bool(value);
@@ -590,7 +590,7 @@ JNIEXPORT jint JNICALL Java_com_android_camera_panorama_Mosaic_createMosaic(
     return (jint) ret;
 }
 
-JNIEXPORT jintArray JNICALL Java_com_android_camera_panorama_Mosaic_getFinalMosaic(
+JNIEXPORT jintArray JNICALL Java_com_android_camera_Mosaic_getFinalMosaic(
         JNIEnv* env, jobject thiz)
 {
     int y,x;
@@ -635,7 +635,7 @@ JNIEXPORT jintArray JNICALL Java_com_android_camera_panorama_Mosaic_getFinalMosa
     return bytes;
 }
 
-JNIEXPORT jbyteArray JNICALL Java_com_android_camera_panorama_Mosaic_getFinalMosaicNV21(
+JNIEXPORT jbyteArray JNICALL Java_com_android_camera_Mosaic_getFinalMosaicNV21(
         JNIEnv* env, jobject thiz)
 {
     int y,x;
diff --git a/jni/mosaic_renderer_jni.cpp b/jni/mosaic_renderer_jni.cpp
index af1cc07..6f449ad 100644
--- a/jni/mosaic_renderer_jni.cpp
+++ b/jni/mosaic_renderer_jni.cpp
@@ -463,24 +463,24 @@ void FreeTextureMemory()
 
 extern "C"
 {
-    JNIEXPORT jint JNICALL Java_com_android_camera_panorama_MosaicRenderer_init(
+    JNIEXPORT jint JNICALL Java_com_android_camera_MosaicRenderer_init(
             JNIEnv * env, jobject obj);
-    JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_reset(
+    JNIEXPORT void JNICALL Java_com_android_camera_MosaicRenderer_reset(
             JNIEnv * env, jobject obj,  jint width, jint height,
             jboolean isLandscapeOrientation);
-    JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_preprocess(
+    JNIEXPORT void JNICALL Java_com_android_camera_MosaicRenderer_preprocess(
             JNIEnv * env, jobject obj, jfloatArray stMatrix);
-    JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_transferGPUtoCPU(
+    JNIEXPORT void JNICALL Java_com_android_camera_MosaicRenderer_transferGPUtoCPU(
             JNIEnv * env, jobject obj);
-    JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_step(
+    JNIEXPORT void JNICALL Java_com_android_camera_MosaicRenderer_step(
             JNIEnv * env, jobject obj);
-    JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_ready(
+    JNIEXPORT void JNICALL Java_com_android_camera_MosaicRenderer_ready(
             JNIEnv * env, jobject obj);
-    JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_setWarping(
+    JNIEXPORT void JNICALL Java_com_android_camera_MosaicRenderer_setWarping(
             JNIEnv * env, jobject obj, jboolean flag);
 };
 
-JNIEXPORT jint JNICALL Java_com_android_camera_panorama_MosaicRenderer_init(
+JNIEXPORT jint JNICALL Java_com_android_camera_MosaicRenderer_init(
         JNIEnv * env, jobject obj)
 {
     gSurfTexRenderer[LR].InitializeGLProgram();
@@ -544,7 +544,7 @@ void calculateUILayoutScaling(int width, int height, bool isLandscape) {
     }
 }
 
-JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_reset(
+JNIEXPORT void JNICALL Java_com_android_camera_MosaicRenderer_reset(
         JNIEnv * env, jobject obj,  jint width, jint height, jboolean isLandscapeOrientation)
 {
     gIsLandscapeOrientation = isLandscapeOrientation;
@@ -626,7 +626,7 @@ JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_reset(
     gPreview.SetInputTextureType(GL_TEXTURE_2D);
 }
 
-JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_preprocess(
+JNIEXPORT void JNICALL Java_com_android_camera_MosaicRenderer_preprocess(
         JNIEnv * env, jobject obj, jfloatArray stMatrix)
 {
     jfloat *stmat = env->GetFloatArrayElements(stMatrix, 0);
@@ -656,7 +656,7 @@ now_ms(void)
 
 
 
-JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_transferGPUtoCPU(
+JNIEXPORT void JNICALL Java_com_android_camera_MosaicRenderer_transferGPUtoCPU(
         JNIEnv * env, jobject obj)
 {
     double t0, t1, time_c;
@@ -696,7 +696,7 @@ JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_transferG
     glBindFramebuffer(GL_FRAMEBUFFER, 0);
 }
 
-JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_step(
+JNIEXPORT void JNICALL Java_com_android_camera_MosaicRenderer_step(
         JNIEnv * env, jobject obj)
 {
     if(!gWarpImage) // ViewFinder
@@ -730,7 +730,7 @@ JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_step(
     }
 }
 
-JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_setWarping(
+JNIEXPORT void JNICALL Java_com_android_camera_MosaicRenderer_setWarping(
         JNIEnv * env, jobject obj, jboolean flag)
 {
     // TODO: Review this logic
@@ -757,7 +757,7 @@ JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_setWarpin
 }
 
 
-JNIEXPORT void JNICALL Java_com_android_camera_panorama_MosaicRenderer_ready(
+JNIEXPORT void JNICALL Java_com_android_camera_MosaicRenderer_ready(
         JNIEnv * env, jobject obj)
 {
     for(int i=0; i<16; i++)
diff --git a/proguard.flags b/proguard.flags
deleted file mode 100644
index 5bce096..0000000
--- a/proguard.flags
+++ /dev/null
@@ -1,19 +0,0 @@
-# ctors of subclasses of CameraPreference are called with Java reflection.
--keep class * extends com.android.camera.CameraPreference {
-  <init>(...);
-}
-
--keep class com.android.camera.ActivityBase {
-  public int getResultCode();
-  public android.content.Intent getResultData();
-}
-
--keep class com.android.camera.VideoCamera {
-  public boolean isRecording();
-  public void onCancelBgTraining(...);
-  public void onProtectiveCurtainClick(...);
-}
-
--keep class * extends android.app.Activity {
-  @com.android.camera.OnClickAttr <methods>;
-}
diff --git a/res/layout-sw600dp/pano_capture.xml b/res/layout-sw600dp/pano_capture.xml
index 1b2900b..9de0b94 100644
--- a/res/layout-sw600dp/pano_capture.xml
+++ b/res/layout-sw600dp/pano_capture.xml
@@ -58,7 +58,7 @@
                     android:layout_weight="1.67"
                     android:layout_width="match_parent"
                     android:layout_height="0dp">
-                <com.android.camera.panorama.MosaicRendererSurfaceView
+                <com.android.camera.MosaicRendererSurfaceView
                         android:id="@+id/pano_renderer"
                         android:layout_width="match_parent"
                         android:layout_height="match_parent" />
@@ -79,7 +79,7 @@
                         android:layout_width="wrap_content"
                         android:layout_height="wrap_content"
                         android:layout_centerInParent="true">
-                    <com.android.camera.panorama.PanoProgressBar
+                    <com.android.camera.PanoProgressBar
                             android:id="@+id/pano_pan_progress_bar"
                             android:visibility="gone"
                             android:src="@drawable/ic_pan_progression"
diff --git a/res/layout-sw600dp/pano_review.xml b/res/layout-sw600dp/pano_review.xml
index cf1fb54..c8e12a2 100644
--- a/res/layout-sw600dp/pano_review.xml
+++ b/res/layout-sw600dp/pano_review.xml
@@ -70,7 +70,7 @@
                 android:layout_centerInParent="true"
                 android:layout_height="wrap_content"
                 android:layout_width="wrap_content">
-            <com.android.camera.panorama.PanoProgressBar
+            <com.android.camera.PanoProgressBar
                     android:id="@+id/pano_saving_progress_bar"
                     android:src="@drawable/ic_pan_progression"
                     android:layout_centerInParent="true"
diff --git a/res/layout/pano_capture.xml b/res/layout/pano_capture.xml
index 49065fd..8768157 100644
--- a/res/layout/pano_capture.xml
+++ b/res/layout/pano_capture.xml
@@ -39,7 +39,7 @@
                         android:layout_width="wrap_content"
                         android:layout_height="wrap_content"
                         android:layout_centerInParent="true">
-                    <com.android.camera.panorama.PanoProgressBar
+                    <com.android.camera.PanoProgressBar
                             android:id="@+id/pano_pan_progress_bar"
                             android:visibility="gone"
                             android:src="@drawable/ic_pan_progression"
@@ -74,7 +74,7 @@
                     android:layout_weight="1.67"
                     android:layout_width="0dp"
                     android:layout_height="match_parent">
-                <com.android.camera.panorama.MosaicRendererSurfaceView
+                <com.android.camera.MosaicRendererSurfaceView
                         android:id="@+id/pano_renderer"
                         android:layout_width="match_parent"
                         android:layout_height="match_parent" />
diff --git a/res/layout/pano_review.xml b/res/layout/pano_review.xml
index 7b9a92e..5f19e92 100644
--- a/res/layout/pano_review.xml
+++ b/res/layout/pano_review.xml
@@ -41,7 +41,7 @@
                 android:layout_centerInParent="true"
                 android:layout_height="wrap_content"
                 android:layout_width="wrap_content">
-            <com.android.camera.panorama.PanoProgressBar
+            <com.android.camera.PanoProgressBar
                     android:id="@+id/pano_saving_progress_bar"
                     android:src="@drawable/ic_pan_progression"
                     android:layout_centerInParent="true"
diff --git a/res/xml/camera_preferences.xml b/res/xml/camera_preferences.xml
index d9ffcd6..15a62b1 100644
--- a/res/xml/camera_preferences.xml
+++ b/res/xml/camera_preferences.xml
@@ -15,7 +15,7 @@
 -->
 
 <PreferenceGroup
-        xmlns:camera="http://schemas.android.com/apk/res/com.android.camera"
+        xmlns:camera="http://schemas.android.com/apk/res/com.android.gallery3d"
         camera:title="@string/pref_camera_settings_category">
     <IconListPreference
             camera:key="pref_camera_flashmode_key"
diff --git a/res/xml/video_preferences.xml b/res/xml/video_preferences.xml
index e158139..abc5dfe 100644
--- a/res/xml/video_preferences.xml
+++ b/res/xml/video_preferences.xml
@@ -15,7 +15,7 @@
 -->
 
 <PreferenceGroup
-        xmlns:camera="http://schemas.android.com/apk/res/com.android.camera"
+        xmlns:camera="http://schemas.android.com/apk/res/com.android.gallery3d"
         camera:title="@string/pref_camcorder_settings_category">
     <IconListPreference
             camera:key="pref_video_quality_key"
diff --git a/src/com/android/camera/MenuHelper.java b/src/com/android/camera/MenuHelper.java
index 576e9c4..4feade1 100644
--- a/src/com/android/camera/MenuHelper.java
+++ b/src/com/android/camera/MenuHelper.java
@@ -44,7 +44,7 @@ public class MenuHelper {
 
     private static final int NO_ANIMATION = 0;
     private static final String CAMERA_CLASS = "com.android.camera.Camera";
-    private static final String PANORAMA_CLASS = "com.android.camera.panorama.PanoramaActivity";
+    private static final String PANORAMA_CLASS = "com.android.camera.PanoramaActivity";
     private static final String VIDEO_CAMERA_CLASS = "com.android.camera.VideoCamera";
 
     public static void addSwitchModeMenuItem(Menu menu, int mode,
diff --git a/src/com/android/camera/Mosaic.java b/src/com/android/camera/Mosaic.java
new file mode 100644
index 0000000..ce60908
--- /dev/null
+++ b/src/com/android/camera/Mosaic.java
@@ -0,0 +1,206 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera;
+
+/**
+ * The Java interface to JNI calls regarding mosaic stitching.
+ *
+ * A high-level usage is:
+ *
+ * Mosaic mosaic = new Mosaic();
+ * mosaic.setSourceImageDimensions(width, height);
+ * mosaic.reset(blendType);
+ *
+ * while ((pixels = hasNextImage()) != null) {
+ *    mosaic.setSourceImage(pixels);
+ * }
+ *
+ * mosaic.createMosaic(highRes);
+ * byte[] result = mosaic.getFinalMosaic();
+ *
+ */
+public class Mosaic {
+    /**
+     * In this mode, the images are stitched together in the same spatial arrangement as acquired
+     * i.e. if the user follows a curvy trajectory, the image boundary of the resulting mosaic will
+     * be curved in the same manner. This mode is useful if the user wants to capture a mosaic as
+     * if "painting" the scene using the smart-phone device and does not want any corrective warps
+     * to distort the captured images.
+     */
+    public static final int BLENDTYPE_FULL = 0;
+
+    /**
+     * This mode is the same as BLENDTYPE_FULL except that the resulting mosaic is rotated
+     * to balance the first and last images to be approximately at the same vertical offset in the
+     * output mosaic. This is useful when acquiring a mosaic by a typical panning-like motion to
+     * remove a one-sided curve in the mosaic (typically due to the camera not staying horizontal
+     * during the video capture) and convert it to a more symmetrical "smiley-face" like output.
+     */
+    public static final int BLENDTYPE_PAN = 1;
+
+    /**
+     * This mode compensates for typical "smiley-face" like output in longer mosaics and creates
+     * a rectangular mosaic with minimal black borders (by unwrapping the mosaic onto an imaginary
+     * cylinder). If the user follows a curved trajectory (instead of a perfect panning trajectory),
+     * the resulting mosaic here may suffer from some image distortions in trying to map the
+     * trajectory to a cylinder.
+     */
+    public static final int BLENDTYPE_CYLINDERPAN = 2;
+
+    /**
+     * This mode is basically BLENDTYPE_CYLINDERPAN plus doing a rectangle cropping before returning
+     * the mosaic. The mode is useful for making the resulting mosaic have a rectangle shape.
+     */
+    public static final int BLENDTYPE_HORIZONTAL =3;
+
+    /**
+     * This strip type will use the default thin strips where the strips are
+     * spaced according to the image capture rate.
+     */
+    public static final int STRIPTYPE_THIN = 0;
+
+    /**
+     * This strip type will use wider strips for blending. The strip separation
+     * is controlled by a threshold on the native side. Since the strips are
+     * wider, there is an additional cross-fade blending step to make the seam
+     * boundaries smoother. Since this mode uses lesser image frames, it is
+     * computationally more efficient than the thin strip mode.
+     */
+    public static final int STRIPTYPE_WIDE = 1;
+
+    /**
+     * Return flags returned by createMosaic() are one of the following.
+     */
+    public static final int MOSAIC_RET_OK = 1;
+    public static final int MOSAIC_RET_ERROR = -1;
+    public static final int MOSAIC_RET_CANCELLED = -2;
+    public static final int MOSAIC_RET_LOW_TEXTURE = -3;
+    public static final int MOSAIC_RET_FEW_INLIERS = 2;
+
+
+    static {
+        System.loadLibrary("jni_legacymosaic");
+    }
+
+    /**
+     * Allocate memory for the image frames at the given resolution.
+     *
+     * @param width width of the input frames in pixels
+     * @param height height of the input frames in pixels
+     */
+    public native void allocateMosaicMemory(int width, int height);
+
+    /**
+     * Free memory allocated by allocateMosaicMemory.
+     *
+     */
+    public native void freeMosaicMemory();
+
+    /**
+     * Pass the input image frame to the native layer. Each time the a new
+     * source image t is set, the transformation matrix from the first source
+     * image to t is computed and returned.
+     *
+     * @param pixels source image of NV21 format.
+     * @return Float array of length 11; first 9 entries correspond to the 3x3
+     *         transformation matrix between the first frame and the passed frame;
+     *         the 10th entry is the number of the passed frame, where the counting
+     *         starts from 1; and the 11th entry is the returning code, whose value
+     *         is one of those MOSAIC_RET_* returning flags defined above.
+     */
+    public native float[] setSourceImage(byte[] pixels);
+
+    /**
+     * This is an alternative to the setSourceImage function above. This should
+     * be called when the image data is already on the native side in a fixed
+     * byte array. In implementation, this array is filled by the GL thread
+     * using glReadPixels directly from GPU memory (where it is accessed by
+     * an associated SurfaceTexture).
+     *
+     * @return Float array of length 11; first 9 entries correspond to the 3x3
+     *         transformation matrix between the first frame and the passed frame;
+     *         the 10th entry is the number of the passed frame, where the counting
+     *         starts from 1; and the 11th entry is the returning code, whose value
+     *         is one of those MOSAIC_RET_* returning flags defined above.
+     */
+    public native float[] setSourceImageFromGPU();
+
+    /**
+     * Set the type of blending.
+     *
+     * @param type the blending type defined in the class. {BLENDTYPE_FULL,
+     *        BLENDTYPE_PAN, BLENDTYPE_CYLINDERPAN, BLENDTYPE_HORIZONTAL}
+     */
+    public native void setBlendingType(int type);
+
+    /**
+     * Set the type of strips to use for blending.
+     * @param type the blending strip type to use {STRIPTYPE_THIN,
+     * STRIPTYPE_WIDE}.
+     */
+    public native void setStripType(int type);
+
+    /**
+     * Tell the native layer to create the final mosaic after all the input frame
+     * data have been collected.
+     * The case of generating high-resolution mosaic may take dozens of seconds to finish.
+     *
+     * @param value True means generating a high-resolution mosaic -
+     *        which is based on the original images set in setSourceImage().
+     *        False means generating a low-resolution version -
+     *        which is based on 1/4 downscaled images from the original images.
+     * @return Returns a status code suggesting if the mosaic building was
+     *        successful, in error, or was cancelled by the user.
+     */
+    public native int createMosaic(boolean value);
+
+    /**
+     * Get the data for the created mosaic.
+     *
+     * @return Returns an integer array which contains the final mosaic in the ARGB_8888 format.
+     *         The first MosaicWidth*MosaicHeight values contain the image data, followed by 2
+     *         integers corresponding to the values MosaicWidth and MosaicHeight respectively.
+     */
+    public native int[] getFinalMosaic();
+
+    /**
+     * Get the data for the created mosaic.
+     *
+     * @return Returns a byte array which contains the final mosaic in the NV21 format.
+     *         The first MosaicWidth*MosaicHeight*1.5 values contain the image data, followed by
+     *         8 bytes which pack the MosaicWidth and MosaicHeight integers into 4 bytes each
+     *         respectively.
+     */
+    public native byte[] getFinalMosaicNV21();
+
+    /**
+     * Reset the state of the frame arrays which maintain the captured frame data.
+     * Also re-initializes the native mosaic object to make it ready for capturing a new mosaic.
+     */
+    public native void reset();
+
+    /**
+     * Get the progress status of the mosaic computation process.
+     * @param hires Boolean flag to select whether to report progress of the
+     *              low-res or high-res mosaicer.
+     * @param cancelComputation Boolean flag to allow cancelling the
+     *              mosaic computation when needed from the GUI end.
+     * @return Returns a number from 0-100 where 50 denotes that the mosaic
+     *          computation is 50% done.
+     */
+    public native int reportProgress(boolean hires, boolean cancelComputation);
+}
diff --git a/src/com/android/camera/MosaicFrameProcessor.java b/src/com/android/camera/MosaicFrameProcessor.java
new file mode 100644
index 0000000..5edc8c5
--- /dev/null
+++ b/src/com/android/camera/MosaicFrameProcessor.java
@@ -0,0 +1,237 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera;
+
+import android.util.Log;
+
+/**
+ * Class to handle the processing of each frame by Mosaicer.
+ */
+public class MosaicFrameProcessor {
+    private static final boolean LOGV = true;
+    private static final String TAG = "MosaicFrameProcessor";
+    private static final int NUM_FRAMES_IN_BUFFER = 2;
+    private static final int MAX_NUMBER_OF_FRAMES = 100;
+    private static final int MOSAIC_RET_CODE_INDEX = 10;
+    private static final int FRAME_COUNT_INDEX = 9;
+    private static final int X_COORD_INDEX = 2;
+    private static final int Y_COORD_INDEX = 5;
+    private static final int HR_TO_LR_DOWNSAMPLE_FACTOR = 4;
+    private static final int WINDOW_SIZE = 3;
+
+    private Mosaic mMosaicer;
+    private boolean mIsMosaicMemoryAllocated = false;
+    private final long [] mFrameTimestamp = new long[NUM_FRAMES_IN_BUFFER];
+    private float mTranslationLastX;
+    private float mTranslationLastY;
+
+    private int mFillIn = 0;
+    private int mTotalFrameCount = 0;
+    private long mLastProcessedFrameTimestamp = 0;
+    private int mLastProcessFrameIdx = -1;
+    private int mCurrProcessFrameIdx = -1;
+
+    // Panning rate is in unit of percentage of image content translation / second.
+    // Use the moving average to calculate the panning rate.
+    private float mPanningRateX;
+    private float mPanningRateY;
+
+    private float[] mDeltaX = new float[WINDOW_SIZE];
+    private float[] mDeltaY = new float[WINDOW_SIZE];
+    private float[] mDeltaTime = new float[WINDOW_SIZE];
+    private int mOldestIdx = 0;
+    private float mTotalTranslationX = 0f;
+    private float mTotalTranslationY = 0f;
+    private float mTotalDeltaTime = 0f;
+
+    private ProgressListener mProgressListener;
+
+    private int mPreviewWidth;
+    private int mPreviewHeight;
+    private int mPreviewBufferSize;
+
+    public interface ProgressListener {
+        public void onProgress(boolean isFinished, float panningRateX, float panningRateY,
+                float progressX, float progressY);
+    }
+
+    public MosaicFrameProcessor(int previewWidth, int previewHeight, int bufSize) {
+        mMosaicer = new Mosaic();
+        mPreviewWidth = previewWidth;
+        mPreviewHeight = previewHeight;
+        mPreviewBufferSize = bufSize;
+    }
+
+    public void setProgressListener(ProgressListener listener) {
+        mProgressListener = listener;
+    }
+
+    public int reportProgress(boolean hires, boolean cancel) {
+        return mMosaicer.reportProgress(hires, cancel);
+    }
+
+    public void initialize() {
+        setupMosaicer(mPreviewWidth, mPreviewHeight, mPreviewBufferSize);
+        setStripType(Mosaic.STRIPTYPE_WIDE);
+        reset();
+    }
+
+    public void clear() {
+        if (mIsMosaicMemoryAllocated) {
+            mIsMosaicMemoryAllocated = false;
+            mMosaicer.freeMosaicMemory();
+        }
+    }
+
+    public void setStripType(int type) {
+        mMosaicer.setStripType(type);
+    }
+
+    private void setupMosaicer(int previewWidth, int previewHeight, int bufSize) {
+        Log.v(TAG, "setupMosaicer w, h=" + previewWidth + ',' + previewHeight + ',' + bufSize);
+        mMosaicer.allocateMosaicMemory(previewWidth, previewHeight);
+        mIsMosaicMemoryAllocated = true;
+
+        mFillIn = 0;
+        if  (mMosaicer != null) {
+            mMosaicer.reset();
+        }
+    }
+
+    public void reset() {
+        // reset() can be called even if MosaicFrameProcessor is not initialized.
+        // Only counters will be changed.
+        mTotalFrameCount = 0;
+        mFillIn = 0;
+        mLastProcessedFrameTimestamp = 0;
+        mTotalTranslationX = 0;
+        mTranslationLastX = 0;
+        mTotalTranslationY = 0;
+        mTranslationLastY = 0;
+        mTotalDeltaTime = 0;
+        mPanningRateX = 0;
+        mPanningRateY = 0;
+        mLastProcessFrameIdx = -1;
+        mCurrProcessFrameIdx = -1;
+        for (int i = 0; i < WINDOW_SIZE; ++i) {
+            mDeltaX[i] = 0f;
+            mDeltaY[i] = 0f;
+            mDeltaTime[i] = 0f;
+        }
+        mMosaicer.reset();
+    }
+
+    public int createMosaic(boolean highRes) {
+        return mMosaicer.createMosaic(highRes);
+    }
+
+    public byte[] getFinalMosaicNV21() {
+        return mMosaicer.getFinalMosaicNV21();
+    }
+
+    // Processes the last filled image frame through the mosaicer and
+    // updates the UI to show progress.
+    // When done, processes and displays the final mosaic.
+    public void processFrame() {
+        if (!mIsMosaicMemoryAllocated) {
+            // clear() is called and buffers are cleared, stop computation.
+            // This can happen when the onPause() is called in the activity, but still some frames
+            // are not processed yet and thus the callback may be invoked.
+            return;
+        }
+        long t1 = System.currentTimeMillis();
+        mFrameTimestamp[mFillIn] = t1;
+
+        mCurrProcessFrameIdx = mFillIn;
+        mFillIn = ((mFillIn + 1) % NUM_FRAMES_IN_BUFFER);
+
+        // Check that we are trying to process a frame different from the
+        // last one processed (useful if this class was running asynchronously)
+        if (mCurrProcessFrameIdx != mLastProcessFrameIdx) {
+            mLastProcessFrameIdx = mCurrProcessFrameIdx;
+
+            // Access the timestamp associated with it...
+            long timestamp = mFrameTimestamp[mCurrProcessFrameIdx];
+
+            // TODO: make the termination condition regarding reaching
+            // MAX_NUMBER_OF_FRAMES solely determined in the library.
+            if (mTotalFrameCount < MAX_NUMBER_OF_FRAMES) {
+                // If we are still collecting new frames for the current mosaic,
+                // process the new frame.
+                calculateTranslationRate(timestamp);
+
+                // Publish progress of the ongoing processing
+                if (mProgressListener != null) {
+                    mProgressListener.onProgress(false, mPanningRateX, mPanningRateY,
+                            mTranslationLastX * HR_TO_LR_DOWNSAMPLE_FACTOR / mPreviewWidth,
+                            mTranslationLastY * HR_TO_LR_DOWNSAMPLE_FACTOR / mPreviewHeight);
+                }
+            } else {
+                if (mProgressListener != null) {
+                    mProgressListener.onProgress(true, mPanningRateX, mPanningRateY,
+                            mTranslationLastX * HR_TO_LR_DOWNSAMPLE_FACTOR / mPreviewWidth,
+                            mTranslationLastY * HR_TO_LR_DOWNSAMPLE_FACTOR / mPreviewHeight);
+                }
+            }
+        }
+    }
+
+    public void calculateTranslationRate(long now) {
+        float[] frameData = mMosaicer.setSourceImageFromGPU();
+        int ret_code = (int) frameData[MOSAIC_RET_CODE_INDEX];
+        mTotalFrameCount  = (int) frameData[FRAME_COUNT_INDEX];
+        float translationCurrX = frameData[X_COORD_INDEX];
+        float translationCurrY = frameData[Y_COORD_INDEX];
+
+        if (mLastProcessedFrameTimestamp == 0f) {
+            // First time: no need to update delta values.
+            mTranslationLastX = translationCurrX;
+            mTranslationLastY = translationCurrY;
+            mLastProcessedFrameTimestamp = now;
+            return;
+        }
+
+        // Moving average: remove the oldest translation/deltaTime and
+        // add the newest translation/deltaTime in
+        int idx = mOldestIdx;
+        mTotalTranslationX -= mDeltaX[idx];
+        mTotalTranslationY -= mDeltaY[idx];
+        mTotalDeltaTime -= mDeltaTime[idx];
+        mDeltaX[idx] = Math.abs(translationCurrX - mTranslationLastX);
+        mDeltaY[idx] = Math.abs(translationCurrY - mTranslationLastY);
+        mDeltaTime[idx] = (now - mLastProcessedFrameTimestamp) / 1000.0f;
+        mTotalTranslationX += mDeltaX[idx];
+        mTotalTranslationY += mDeltaY[idx];
+        mTotalDeltaTime += mDeltaTime[idx];
+
+        // The panning rate is measured as the rate of the translation percentage in
+        // image width/height. Take the horizontal panning rate for example, the image width
+        // used in finding the translation is (PreviewWidth / HR_TO_LR_DOWNSAMPLE_FACTOR).
+        // To get the horizontal translation percentage, the horizontal translation,
+        // (translationCurrX - mTranslationLastX), is divided by the
+        // image width. We then get the rate by dividing the translation percentage with deltaTime.
+        mPanningRateX = mTotalTranslationX /
+                (mPreviewWidth / HR_TO_LR_DOWNSAMPLE_FACTOR) / mTotalDeltaTime;
+        mPanningRateY = mTotalTranslationY /
+                (mPreviewHeight / HR_TO_LR_DOWNSAMPLE_FACTOR) / mTotalDeltaTime;
+
+        mTranslationLastX = translationCurrX;
+        mTranslationLastY = translationCurrY;
+        mLastProcessedFrameTimestamp = now;
+        mOldestIdx = (mOldestIdx + 1) % WINDOW_SIZE;
+    }
+}
diff --git a/src/com/android/camera/MosaicRenderer.java b/src/com/android/camera/MosaicRenderer.java
new file mode 100644
index 0000000..0b13395
--- /dev/null
+++ b/src/com/android/camera/MosaicRenderer.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera;
+
+/**
+ * The Java interface to JNI calls regarding mosaic preview rendering.
+ *
+ */
+public class MosaicRenderer
+{
+     static
+     {
+         System.loadLibrary("jni_legacymosaic");
+     }
+
+     /**
+      * Function to be called in onSurfaceCreated() to initialize
+      * the GL context, load and link the shaders and create the
+      * program. Returns a texture ID to be used for SurfaceTexture.
+      *
+      * @return textureID the texture ID of the newly generated texture to
+      *          be assigned to the SurfaceTexture object.
+      */
+     public static native int init();
+
+     /**
+      * Pass the drawing surface's width and height to initialize the
+      * renderer viewports and FBO dimensions.
+      *
+      * @param width width of the drawing surface in pixels.
+      * @param height height of the drawing surface in pixels.
+      * @param isLandscapeOrientation is the orientation of the activity layout in landscape.
+      */
+     public static native void reset(int width, int height, boolean isLandscapeOrientation);
+
+     /**
+      * Calling this function will render the SurfaceTexture to a new 2D texture
+      * using the provided STMatrix.
+      *
+      * @param stMatrix texture coordinate transform matrix obtained from the
+      *        Surface texture
+      */
+     public static native void preprocess(float[] stMatrix);
+
+     /**
+      * This function calls glReadPixels to transfer both the low-res and high-res
+      * data from the GPU memory to the CPU memory for further processing by the
+      * mosaicing library.
+      */
+     public static native void transferGPUtoCPU();
+
+     /**
+      * Function to be called in onDrawFrame() to update the screen with
+      * the new frame data.
+      */
+     public static native void step();
+
+     /**
+      * Call this function when a new low-res frame has been processed by
+      * the mosaicing library. This will tell the renderer library to
+      * update its texture and warping transformation. Any calls to step()
+      * after this call will use the new image frame and transformation data.
+      */
+     public static native void ready();
+
+     /**
+      * This function allows toggling between showing the input image data
+      * (without applying any warp) and the warped image data. For running
+      * the renderer as a viewfinder, we set the flag to false. To see the
+      * preview mosaic, we set the flag to true.
+      *
+      * @param flag boolean flag to set the warping to true or false.
+      */
+     public static native void setWarping(boolean flag);
+}
diff --git a/src/com/android/camera/MosaicRendererSurfaceView.java b/src/com/android/camera/MosaicRendererSurfaceView.java
new file mode 100644
index 0000000..6658149
--- /dev/null
+++ b/src/com/android/camera/MosaicRendererSurfaceView.java
@@ -0,0 +1,374 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.pm.ActivityInfo;
+import android.graphics.PixelFormat;
+import android.opengl.GLSurfaceView;
+import android.os.ConditionVariable;
+import android.util.AttributeSet;
+import android.util.Log;
+
+import javax.microedition.khronos.egl.EGL10;
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.egl.EGLContext;
+import javax.microedition.khronos.egl.EGLDisplay;
+
+public class MosaicRendererSurfaceView extends GLSurfaceView {
+    private static final String TAG = "MosaicRendererSurfaceView";
+    private static final boolean DEBUG = false;
+    private MosaicRendererSurfaceViewRenderer mRenderer;
+    private ConditionVariable mPreviewFrameReadyForProcessing;
+    private boolean mIsLandscapeOrientation = true;
+
+    public MosaicRendererSurfaceView(Context context) {
+        super(context);
+        initialize(context, false, 0, 0);
+    }
+
+    public MosaicRendererSurfaceView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        initialize(context, false, 0, 0);
+    }
+
+    public MosaicRendererSurfaceView(Context context, boolean translucent,
+            int depth, int stencil) {
+        super(context);
+        initialize(context, translucent, depth, stencil);
+    }
+
+    private void initialize(Context context, boolean translucent, int depth, int stencil) {
+        getDisplayOrientation(context);
+        init(translucent, depth, stencil);
+        setZOrderMediaOverlay(true);
+    }
+
+    private void getDisplayOrientation(Context context) {
+        Activity activity = (PanoramaActivity) context;
+        mIsLandscapeOrientation = (activity.getRequestedOrientation()
+                == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE );
+    }
+
+    private void init(boolean translucent, int depth, int stencil) {
+
+        /* By default, GLSurfaceView() creates a RGB_565 opaque surface.
+         * If we want a translucent one, we should change the surface's
+         * format here, using PixelFormat.TRANSLUCENT for GL Surfaces
+         * is interpreted as any 32-bit surface with alpha by SurfaceFlinger.
+         */
+        if (translucent) {
+            this.getHolder().setFormat(PixelFormat.TRANSLUCENT);
+        }
+
+        /* Setup the context factory for 2.0 rendering.
+         * See ContextFactory class definition below
+         */
+        setEGLContextFactory(new ContextFactory());
+
+        /* We need to choose an EGLConfig that matches the format of
+         * our surface exactly. This is going to be done in our
+         * custom config chooser. See ConfigChooser class definition
+         * below.
+         */
+        setEGLConfigChooser(
+            translucent ? new ConfigChooser(8, 8, 8, 8, depth, stencil) :
+            new ConfigChooser(5, 6, 5, 0, depth, stencil));
+
+        /* Set the renderer responsible for frame rendering */
+        mRenderer = new MosaicRendererSurfaceViewRenderer(mIsLandscapeOrientation);
+        setRenderer(mRenderer);
+        setRenderMode(RENDERMODE_WHEN_DIRTY);
+        mPreviewFrameReadyForProcessing = new ConditionVariable();
+    }
+
+    private static class ContextFactory implements GLSurfaceView.EGLContextFactory {
+        private static int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
+        public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig) {
+            Log.w(TAG, "creating OpenGL ES 2.0 context");
+            checkEglError("Before eglCreateContext", egl);
+            int[] attribList = {EGL_CONTEXT_CLIENT_VERSION, 2, EGL10.EGL_NONE };
+            EGLContext context = egl.eglCreateContext(
+                display, eglConfig, EGL10.EGL_NO_CONTEXT, attribList);
+            checkEglError("After eglCreateContext", egl);
+            return context;
+        }
+
+        public void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context) {
+            egl.eglDestroyContext(display, context);
+        }
+    }
+
+    private static void checkEglError(String prompt, EGL10 egl) {
+        int error;
+        while ((error = egl.eglGetError()) != EGL10.EGL_SUCCESS) {
+            Log.e(TAG, String.format("%s: EGL error: 0x%x", prompt, error));
+        }
+    }
+
+    private static class ConfigChooser implements GLSurfaceView.EGLConfigChooser {
+
+        public ConfigChooser(int r, int g, int b, int a, int depth, int stencil) {
+            mRedSize = r;
+            mGreenSize = g;
+            mBlueSize = b;
+            mAlphaSize = a;
+            mDepthSize = depth;
+            mStencilSize = stencil;
+        }
+
+        /* This EGL config specification is used to specify 2.0 rendering.
+         * We use a minimum size of 4 bits for red/green/blue, but will
+         * perform actual matching in chooseConfig() below.
+         */
+        private static final int EGL_OPENGL_ES2_BIT = 4;
+        private static final int[] CONFIG_ATTRIBUTES =
+        {
+            EGL10.EGL_RED_SIZE, 4,
+            EGL10.EGL_GREEN_SIZE, 4,
+            EGL10.EGL_BLUE_SIZE, 4,
+            EGL10.EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+            EGL10.EGL_NONE
+        };
+
+        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) {
+
+            /* Get the number of minimally matching EGL configurations
+             */
+            int[] numConfig = new int[1];
+            egl.eglChooseConfig(display, CONFIG_ATTRIBUTES, null, 0, numConfig);
+
+            int numConfigs = numConfig[0];
+
+            if (numConfigs <= 0) {
+                throw new IllegalArgumentException("No configs match configSpec");
+            }
+
+            /* Allocate then read the array of minimally matching EGL configs
+             */
+            EGLConfig[] configs = new EGLConfig[numConfigs];
+            egl.eglChooseConfig(display, CONFIG_ATTRIBUTES, configs, numConfigs, numConfig);
+
+            if (DEBUG) {
+                 printConfigs(egl, display, configs);
+            }
+            /* Now return the "best" one
+             */
+            return chooseConfig(egl, display, configs);
+        }
+
+        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
+                EGLConfig[] configs) {
+            for (EGLConfig config : configs) {
+                int d = findConfigAttrib(egl, display, config,
+                        EGL10.EGL_DEPTH_SIZE, 0);
+                int s = findConfigAttrib(egl, display, config,
+                        EGL10.EGL_STENCIL_SIZE, 0);
+
+                // We need at least mDepthSize and mStencilSize bits
+                if (d < mDepthSize || s < mStencilSize)
+                    continue;
+
+                // We want an *exact* match for red/green/blue/alpha
+                int r = findConfigAttrib(egl, display, config,
+                        EGL10.EGL_RED_SIZE, 0);
+                int g = findConfigAttrib(egl, display, config,
+                            EGL10.EGL_GREEN_SIZE, 0);
+                int b = findConfigAttrib(egl, display, config,
+                            EGL10.EGL_BLUE_SIZE, 0);
+                int a = findConfigAttrib(egl, display, config,
+                        EGL10.EGL_ALPHA_SIZE, 0);
+
+                if (r == mRedSize && g == mGreenSize && b == mBlueSize && a == mAlphaSize)
+                    return config;
+            }
+            return null;
+        }
+
+        private int findConfigAttrib(EGL10 egl, EGLDisplay display,
+                EGLConfig config, int attribute, int defaultValue) {
+
+            if (egl.eglGetConfigAttrib(display, config, attribute, mValue)) {
+                return mValue[0];
+            }
+            return defaultValue;
+        }
+
+        private void printConfigs(EGL10 egl, EGLDisplay display,
+            EGLConfig[] configs) {
+            int numConfigs = configs.length;
+            Log.w(TAG, String.format("%d configurations", numConfigs));
+            for (int i = 0; i < numConfigs; i++) {
+                Log.w(TAG, String.format("Configuration %d:\n", i));
+                printConfig(egl, display, configs[i]);
+            }
+        }
+
+        private void printConfig(EGL10 egl, EGLDisplay display,
+                EGLConfig config) {
+            int[] attributes = {
+                    EGL10.EGL_BUFFER_SIZE,
+                    EGL10.EGL_ALPHA_SIZE,
+                    EGL10.EGL_BLUE_SIZE,
+                    EGL10.EGL_GREEN_SIZE,
+                    EGL10.EGL_RED_SIZE,
+                    EGL10.EGL_DEPTH_SIZE,
+                    EGL10.EGL_STENCIL_SIZE,
+                    EGL10.EGL_CONFIG_CAVEAT,
+                    EGL10.EGL_CONFIG_ID,
+                    EGL10.EGL_LEVEL,
+                    EGL10.EGL_MAX_PBUFFER_HEIGHT,
+                    EGL10.EGL_MAX_PBUFFER_PIXELS,
+                    EGL10.EGL_MAX_PBUFFER_WIDTH,
+                    EGL10.EGL_NATIVE_RENDERABLE,
+                    EGL10.EGL_NATIVE_VISUAL_ID,
+                    EGL10.EGL_NATIVE_VISUAL_TYPE,
+                    0x3030, // EGL10.EGL_PRESERVED_RESOURCES,
+                    EGL10.EGL_SAMPLES,
+                    EGL10.EGL_SAMPLE_BUFFERS,
+                    EGL10.EGL_SURFACE_TYPE,
+                    EGL10.EGL_TRANSPARENT_TYPE,
+                    EGL10.EGL_TRANSPARENT_RED_VALUE,
+                    EGL10.EGL_TRANSPARENT_GREEN_VALUE,
+                    EGL10.EGL_TRANSPARENT_BLUE_VALUE,
+                    0x3039, // EGL10.EGL_BIND_TO_TEXTURE_RGB,
+                    0x303A, // EGL10.EGL_BIND_TO_TEXTURE_RGBA,
+                    0x303B, // EGL10.EGL_MIN_SWAP_INTERVAL,
+                    0x303C, // EGL10.EGL_MAX_SWAP_INTERVAL,
+                    EGL10.EGL_LUMINANCE_SIZE,
+                    EGL10.EGL_ALPHA_MASK_SIZE,
+                    EGL10.EGL_COLOR_BUFFER_TYPE,
+                    EGL10.EGL_RENDERABLE_TYPE,
+                    0x3042 // EGL10.EGL_CONFORMANT
+            };
+            String[] names = {
+                    "EGL_BUFFER_SIZE",
+                    "EGL_ALPHA_SIZE",
+                    "EGL_BLUE_SIZE",
+                    "EGL_GREEN_SIZE",
+                    "EGL_RED_SIZE",
+                    "EGL_DEPTH_SIZE",
+                    "EGL_STENCIL_SIZE",
+                    "EGL_CONFIG_CAVEAT",
+                    "EGL_CONFIG_ID",
+                    "EGL_LEVEL",
+                    "EGL_MAX_PBUFFER_HEIGHT",
+                    "EGL_MAX_PBUFFER_PIXELS",
+                    "EGL_MAX_PBUFFER_WIDTH",
+                    "EGL_NATIVE_RENDERABLE",
+                    "EGL_NATIVE_VISUAL_ID",
+                    "EGL_NATIVE_VISUAL_TYPE",
+                    "EGL_PRESERVED_RESOURCES",
+                    "EGL_SAMPLES",
+                    "EGL_SAMPLE_BUFFERS",
+                    "EGL_SURFACE_TYPE",
+                    "EGL_TRANSPARENT_TYPE",
+                    "EGL_TRANSPARENT_RED_VALUE",
+                    "EGL_TRANSPARENT_GREEN_VALUE",
+                    "EGL_TRANSPARENT_BLUE_VALUE",
+                    "EGL_BIND_TO_TEXTURE_RGB",
+                    "EGL_BIND_TO_TEXTURE_RGBA",
+                    "EGL_MIN_SWAP_INTERVAL",
+                    "EGL_MAX_SWAP_INTERVAL",
+                    "EGL_LUMINANCE_SIZE",
+                    "EGL_ALPHA_MASK_SIZE",
+                    "EGL_COLOR_BUFFER_TYPE",
+                    "EGL_RENDERABLE_TYPE",
+                    "EGL_CONFORMANT"
+            };
+            int[] value = new int[1];
+            for (int i = 0; i < attributes.length; i++) {
+                int attribute = attributes[i];
+                String name = names[i];
+                if (egl.eglGetConfigAttrib(display, config, attribute, value)) {
+                    Log.w(TAG, String.format("  %s: %d\n", name, value[0]));
+                } else {
+                    // Log.w(TAG, String.format("  %s: failed\n", name));
+                    while (egl.eglGetError() != EGL10.EGL_SUCCESS);
+                }
+            }
+        }
+
+        // Subclasses can adjust these values:
+        protected int mRedSize;
+        protected int mGreenSize;
+        protected int mBlueSize;
+        protected int mAlphaSize;
+        protected int mDepthSize;
+        protected int mStencilSize;
+        private int[] mValue = new int[1];
+    }
+
+    public void lockPreviewReadyFlag() {
+        mPreviewFrameReadyForProcessing.close();
+    }
+
+    private void unlockPreviewReadyFlag() {
+        mPreviewFrameReadyForProcessing.open();
+    }
+
+    public void waitUntilPreviewReady() {
+        mPreviewFrameReadyForProcessing.block();
+    }
+
+    public void setReady() {
+        queueEvent(new Runnable() {
+
+            @Override
+            public void run() {
+                mRenderer.setReady();
+            }
+        });
+    }
+
+    public void preprocess(final float[] transformMatrix) {
+        queueEvent(new Runnable() {
+
+            @Override
+            public void run() {
+                mRenderer.preprocess(transformMatrix);
+            }
+        });
+    }
+
+    public void transferGPUtoCPU() {
+        queueEvent(new Runnable() {
+
+            @Override
+            public void run() {
+                mRenderer.transferGPUtoCPU();
+                unlockPreviewReadyFlag();
+            }
+        });
+    }
+
+    public void setWarping(final boolean flag) {
+        queueEvent(new Runnable() {
+
+            @Override
+            public void run() {
+                mRenderer.setWarping(flag);
+            }
+        });
+    }
+
+    public MosaicRendererSurfaceViewRenderer getRenderer() {
+        return mRenderer;
+    }
+
+}
diff --git a/src/com/android/camera/MosaicRendererSurfaceViewRenderer.java b/src/com/android/camera/MosaicRendererSurfaceViewRenderer.java
new file mode 100755
index 0000000..19d84d2
--- /dev/null
+++ b/src/com/android/camera/MosaicRendererSurfaceViewRenderer.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera;
+
+import android.opengl.GLSurfaceView;
+import android.util.Log;
+
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.opengles.GL10;
+
+public class MosaicRendererSurfaceViewRenderer implements GLSurfaceView.Renderer
+{
+    private static final String TAG = "MosaicRendererSurfaceViewRenderer";
+    private boolean mIsLandscapeOrientation;
+
+    private MosaicSurfaceCreateListener mSurfaceCreateListener;
+
+    public MosaicRendererSurfaceViewRenderer(boolean isLandscapeOrientation) {
+        mIsLandscapeOrientation = isLandscapeOrientation;
+    }
+
+    /** A callback to be called when the surface is created */
+    public interface MosaicSurfaceCreateListener {
+        public void onMosaicSurfaceCreated(final int surface);
+        public void onMosaicSurfaceChanged();
+    }
+
+    @Override
+    public void onDrawFrame(GL10 gl) {
+        MosaicRenderer.step();
+    }
+
+    @Override
+    public void onSurfaceChanged(GL10 gl, int width, int height) {
+        MosaicRenderer.reset(width, height, mIsLandscapeOrientation);
+        Log.i(TAG, "Renderer: onSurfaceChanged");
+        if (mSurfaceCreateListener != null) {
+            mSurfaceCreateListener.onMosaicSurfaceChanged();
+        }
+    }
+
+    @Override
+    public void onSurfaceCreated(GL10 gl, EGLConfig config) {
+        Log.i(TAG, "onSurfaceCreated");
+        if (mSurfaceCreateListener != null) {
+            mSurfaceCreateListener.onMosaicSurfaceCreated(MosaicRenderer.init());
+        }
+    }
+
+    public void setMosaicSurfaceCreateListener(MosaicSurfaceCreateListener listener) {
+        mSurfaceCreateListener = listener;
+    }
+
+    public void setReady() {
+        MosaicRenderer.ready();
+    }
+
+    public void preprocess(float[] transformMatrix) {
+        MosaicRenderer.preprocess(transformMatrix);
+    }
+
+    public void transferGPUtoCPU() {
+        MosaicRenderer.transferGPUtoCPU();
+    }
+
+    public void setWarping(boolean flag) {
+        MosaicRenderer.setWarping(flag);
+    }
+}
diff --git a/src/com/android/camera/PanoProgressBar.java b/src/com/android/camera/PanoProgressBar.java
new file mode 100644
index 0000000..979e7f0
--- /dev/null
+++ b/src/com/android/camera/PanoProgressBar.java
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.RectF;
+import android.util.AttributeSet;
+import android.widget.ImageView;
+
+class PanoProgressBar extends ImageView {
+    private static final String TAG = "PanoProgressBar";
+    public static final int DIRECTION_NONE = 0;
+    public static final int DIRECTION_LEFT = 1;
+    public static final int DIRECTION_RIGHT = 2;
+    private float mProgress = 0;
+    private float mMaxProgress = 0;
+    private float mLeftMostProgress = 0;
+    private float mRightMostProgress = 0;
+    private float mProgressOffset = 0;
+    private float mIndicatorWidth = 0;
+    private int mDirection = 0;
+    private final Paint mBackgroundPaint = new Paint();
+    private final Paint mDoneAreaPaint = new Paint();
+    private final Paint mIndicatorPaint = new Paint();
+    private float mWidth;
+    private float mHeight;
+    private RectF mDrawBounds;
+    private OnDirectionChangeListener mListener = null;
+
+    public interface OnDirectionChangeListener {
+        public void onDirectionChange(int direction);
+    }
+
+    public PanoProgressBar(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        mDoneAreaPaint.setStyle(Paint.Style.FILL);
+        mDoneAreaPaint.setAlpha(0xff);
+
+        mBackgroundPaint.setStyle(Paint.Style.FILL);
+        mBackgroundPaint.setAlpha(0xff);
+
+        mIndicatorPaint.setStyle(Paint.Style.FILL);
+        mIndicatorPaint.setAlpha(0xff);
+
+        mDrawBounds = new RectF();
+    }
+
+    public void setOnDirectionChangeListener(OnDirectionChangeListener l) {
+        mListener = l;
+    }
+
+    private void setDirection(int direction) {
+        if (mDirection != direction) {
+            mDirection = direction;
+            if (mListener != null) {
+                mListener.onDirectionChange(mDirection);
+            }
+            invalidate();
+        }
+    }
+
+    public int getDirection() {
+        return mDirection;
+    }
+
+    public void setBackgroundColor(int color) {
+        mBackgroundPaint.setColor(color);
+        invalidate();
+    }
+
+    public void setDoneColor(int color) {
+        mDoneAreaPaint.setColor(color);
+        invalidate();
+    }
+
+    public void setIndicatorColor(int color) {
+        mIndicatorPaint.setColor(color);
+        invalidate();
+    }
+
+    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
+        mWidth = w;
+        mHeight = h;
+        mDrawBounds.set(0, 0, mWidth, mHeight);
+    }
+
+    public void setMaxProgress(int progress) {
+        mMaxProgress = progress;
+    }
+
+    public void setIndicatorWidth(float w) {
+        mIndicatorWidth = w;
+        invalidate();
+    }
+
+    public void setRightIncreasing(boolean rightIncreasing) {
+        if (rightIncreasing) {
+            mLeftMostProgress = 0;
+            mRightMostProgress = 0;
+            mProgressOffset = 0;
+            setDirection(DIRECTION_RIGHT);
+        } else {
+            mLeftMostProgress = mWidth;
+            mRightMostProgress = mWidth;
+            mProgressOffset = mWidth;
+            setDirection(DIRECTION_LEFT);
+        }
+        invalidate();
+    }
+
+    public void setProgress(int progress) {
+        // The panning direction will be decided after user pan more than 10 degrees in one
+        // direction.
+        if (mDirection == DIRECTION_NONE) {
+            if (progress > 10) {
+                setRightIncreasing(true);
+            } else if (progress < -10) {
+                setRightIncreasing(false);
+            }
+        }
+        // mDirection might be modified by setRightIncreasing() above. Need to check again.
+        if (mDirection != DIRECTION_NONE) {
+            mProgress = progress * mWidth / mMaxProgress + mProgressOffset;
+            // value bounds.
+            mProgress = Math.min(mWidth, Math.max(0, mProgress));
+            if (mDirection == DIRECTION_RIGHT) {
+                // The right most progress is adjusted.
+                mRightMostProgress = Math.max(mRightMostProgress, mProgress);
+            }
+            if (mDirection == DIRECTION_LEFT) {
+                // The left most progress is adjusted.
+                mLeftMostProgress = Math.min(mLeftMostProgress, mProgress);
+            }
+            invalidate();
+        }
+    }
+
+    public void reset() {
+        mProgress = 0;
+        mProgressOffset = 0;
+        setDirection(DIRECTION_NONE);
+        invalidate();
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        // the background
+        canvas.drawRect(mDrawBounds, mBackgroundPaint);
+        if (mDirection != DIRECTION_NONE) {
+            // the progress area
+            canvas.drawRect(mLeftMostProgress, mDrawBounds.top, mRightMostProgress,
+                    mDrawBounds.bottom, mDoneAreaPaint);
+            // the indication bar
+            float l;
+            float r;
+            if (mDirection == DIRECTION_RIGHT) {
+                l = Math.max(mProgress - mIndicatorWidth, 0f);
+                r = mProgress;
+            } else {
+                l = mProgress;
+                r = Math.min(mProgress + mIndicatorWidth, mWidth);
+            }
+            canvas.drawRect(l, mDrawBounds.top, r, mDrawBounds.bottom, mIndicatorPaint);
+        }
+
+        // draw the mask image on the top for shaping.
+        super.onDraw(canvas);
+    }
+}
diff --git a/src/com/android/camera/PanoUtil.java b/src/com/android/camera/PanoUtil.java
new file mode 100644
index 0000000..4a7d9d8
--- /dev/null
+++ b/src/com/android/camera/PanoUtil.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera;
+
+import java.text.SimpleDateFormat;
+import java.util.Date;
+
+public class PanoUtil {
+    public static String createName(String format, long dateTaken) {
+        Date date = new Date(dateTaken);
+        SimpleDateFormat dateFormat = new SimpleDateFormat(format);
+        return dateFormat.format(date);
+    }
+
+    // TODO: Add comments about the range of these two arguments.
+    public static double calculateDifferenceBetweenAngles(double firstAngle,
+            double secondAngle) {
+        double difference1 = (secondAngle - firstAngle) % 360;
+        if (difference1 < 0) {
+            difference1 += 360;
+        }
+
+        double difference2 = (firstAngle - secondAngle) % 360;
+        if (difference2 < 0) {
+            difference2 += 360;
+        }
+
+        return Math.min(difference1, difference2);
+    }
+
+    public static void decodeYUV420SPQuarterRes(int[] rgb, byte[] yuv420sp, int width, int height) {
+        final int frameSize = width * height;
+
+        for (int j = 0, ypd = 0; j < height; j += 4) {
+            int uvp = frameSize + (j >> 1) * width, u = 0, v = 0;
+            for (int i = 0; i < width; i += 4, ypd++) {
+                int y = (0xff & ((int) yuv420sp[j * width + i])) - 16;
+                if (y < 0) {
+                    y = 0;
+                }
+                if ((i & 1) == 0) {
+                    v = (0xff & yuv420sp[uvp++]) - 128;
+                    u = (0xff & yuv420sp[uvp++]) - 128;
+                    uvp += 2;  // Skip the UV values for the 4 pixels skipped in between
+                }
+                int y1192 = 1192 * y;
+                int r = (y1192 + 1634 * v);
+                int g = (y1192 - 833 * v - 400 * u);
+                int b = (y1192 + 2066 * u);
+
+                if (r < 0) {
+                    r = 0;
+                } else if (r > 262143) {
+                    r = 262143;
+                }
+                if (g < 0) {
+                    g = 0;
+                } else if (g > 262143) {
+                    g = 262143;
+                }
+                if (b < 0) {
+                    b = 0;
+                } else if (b > 262143) {
+                    b = 262143;
+                }
+
+                rgb[ypd] = 0xff000000 | ((r << 6) & 0xff0000) | ((g >> 2) & 0xff00) |
+                        ((b >> 10) & 0xff);
+            }
+        }
+    }
+}
diff --git a/src/com/android/camera/PanoramaActivity.java b/src/com/android/camera/PanoramaActivity.java
new file mode 100755
index 0000000..01fb095
--- /dev/null
+++ b/src/com/android/camera/PanoramaActivity.java
@@ -0,0 +1,1170 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera;
+
+import com.android.camera.ActivityBase;
+import com.android.camera.CameraDisabledException;
+import com.android.camera.CameraHardwareException;
+import com.android.camera.CameraHolder;
+import com.android.camera.Exif;
+import com.android.camera.MenuHelper;
+import com.android.camera.ModePicker;
+import com.android.camera.OnClickAttr;
+import com.android.camera.R;
+import com.android.camera.RotateDialogController;
+import com.android.camera.ShutterButton;
+import com.android.camera.Storage;
+import com.android.camera.Thumbnail;
+import com.android.camera.Util;
+import com.android.camera.ui.PopupManager;
+import com.android.camera.ui.Rotatable;
+import com.android.camera.ui.RotateImageView;
+import com.android.camera.ui.RotateLayout;
+import com.android.camera.ui.SharePopup;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.res.AssetFileDescriptor;
+import android.content.pm.ActivityInfo;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.ImageFormat;
+import android.graphics.PixelFormat;
+import android.graphics.Rect;
+import android.graphics.SurfaceTexture;
+import android.graphics.YuvImage;
+import android.hardware.Camera.Parameters;
+import android.hardware.Camera.Size;
+import android.hardware.Sensor;
+import android.hardware.SensorManager;
+import android.media.ExifInterface;
+import android.media.MediaActionSound;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.os.ParcelFileDescriptor;
+import android.os.PowerManager;
+import android.util.Log;
+import android.view.Gravity;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.view.OrientationEventListener;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.Window;
+import android.view.WindowManager;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.util.List;
+
+/**
+ * Activity to handle panorama capturing.
+ */
+public class PanoramaActivity extends ActivityBase implements
+        ModePicker.OnModeChangeListener, SurfaceTexture.OnFrameAvailableListener,
+        ShutterButton.OnShutterButtonListener,
+        MosaicRendererSurfaceViewRenderer.MosaicSurfaceCreateListener {
+    public static final int DEFAULT_SWEEP_ANGLE = 160;
+    public static final int DEFAULT_BLEND_MODE = Mosaic.BLENDTYPE_HORIZONTAL;
+    public static final int DEFAULT_CAPTURE_PIXELS = 960 * 720;
+
+    private static final int MSG_LOW_RES_FINAL_MOSAIC_READY = 1;
+    private static final int MSG_RESET_TO_PREVIEW_WITH_THUMBNAIL = 2;
+    private static final int MSG_GENERATE_FINAL_MOSAIC_ERROR = 3;
+    private static final int MSG_RESET_TO_PREVIEW = 4;
+    private static final int MSG_CLEAR_SCREEN_DELAY = 5;
+
+    private static final int SCREEN_DELAY = 2 * 60 * 1000;
+
+    private static final String TAG = "PanoramaActivity";
+    private static final int PREVIEW_STOPPED = 0;
+    private static final int PREVIEW_ACTIVE = 1;
+    private static final int CAPTURE_STATE_VIEWFINDER = 0;
+    private static final int CAPTURE_STATE_MOSAIC = 1;
+
+    // Speed is in unit of deg/sec
+    private static final float PANNING_SPEED_THRESHOLD = 20f;
+
+    // Ratio of nanosecond to second
+    private static final float NS2S = 1.0f / 1000000000.0f;
+
+    private boolean mPausing;
+
+    private View mPanoLayout;
+    private View mCaptureLayout;
+    private View mReviewLayout;
+    private ImageView mReview;
+    private RotateLayout mCaptureIndicator;
+    private PanoProgressBar mPanoProgressBar;
+    private PanoProgressBar mSavingProgressBar;
+    private View mFastIndicationBorder;
+    private View mLeftIndicator;
+    private View mRightIndicator;
+    private MosaicRendererSurfaceView mMosaicView;
+    private TextView mTooFastPrompt;
+    private ShutterButton mShutterButton;
+    private Object mWaitObject = new Object();
+
+    private String mPreparePreviewString;
+    private String mDialogTitle;
+    private String mDialogOkString;
+    private String mDialogPanoramaFailedString;
+
+    private int mIndicatorColor;
+    private int mIndicatorColorFast;
+
+    private float mCompassValueX;
+    private float mCompassValueY;
+    private float mCompassValueXStart;
+    private float mCompassValueYStart;
+    private float mCompassValueXStartBuffer;
+    private float mCompassValueYStartBuffer;
+    private int mCompassThreshold;
+    private int mTraversedAngleX;
+    private int mTraversedAngleY;
+    private long mTimestamp;
+
+    private RotateImageView mThumbnailView;
+    private Thumbnail mThumbnail;
+    private SharePopup mSharePopup;
+
+    private int mPreviewWidth;
+    private int mPreviewHeight;
+    private int mCameraState;
+    private int mCaptureState;
+    private SensorManager mSensorManager;
+    private Sensor mSensor;
+    private PowerManager.WakeLock mPartialWakeLock;
+    private ModePicker mModePicker;
+    private MosaicFrameProcessor mMosaicFrameProcessor;
+    private long mTimeTaken;
+    private Handler mMainHandler;
+    private SurfaceTexture mSurfaceTexture;
+    private boolean mThreadRunning;
+    private boolean mCancelComputation;
+    private float[] mTransformMatrix;
+    private float mHorizontalViewAngle;
+    private float mVerticalViewAngle;
+
+    // Prefer FOCUS_MODE_INFINITY to FOCUS_MODE_CONTINUOUS_VIDEO because of
+    // getting a better image quality by the former.
+    private String mTargetFocusMode = Parameters.FOCUS_MODE_INFINITY;
+
+    private PanoOrientationEventListener mOrientationEventListener;
+    // The value could be 0, 90, 180, 270 for the 4 different orientations measured in clockwise
+    // respectively.
+    private int mDeviceOrientation;
+    private int mDeviceOrientationAtCapture;
+    private int mCameraOrientation;
+    private int mOrientationCompensation;
+
+    private RotateDialogController mRotateDialog;
+
+    private MediaActionSound mCameraSound;
+
+    private class MosaicJpeg {
+        public MosaicJpeg(byte[] data, int width, int height) {
+            this.data = data;
+            this.width = width;
+            this.height = height;
+            this.isValid = true;
+        }
+
+        public MosaicJpeg() {
+            this.data = null;
+            this.width = 0;
+            this.height = 0;
+            this.isValid = false;
+        }
+
+        public final byte[] data;
+        public final int width;
+        public final int height;
+        public final boolean isValid;
+    }
+
+    private class PanoOrientationEventListener extends OrientationEventListener {
+        public PanoOrientationEventListener(Context context) {
+            super(context);
+        }
+
+        @Override
+        public void onOrientationChanged(int orientation) {
+            // We keep the last known orientation. So if the user first orient
+            // the camera then point the camera to floor or sky, we still have
+            // the correct orientation.
+            if (orientation == ORIENTATION_UNKNOWN) return;
+            mDeviceOrientation = Util.roundOrientation(orientation, mDeviceOrientation);
+            // When the screen is unlocked, display rotation may change. Always
+            // calculate the up-to-date orientationCompensation.
+            int orientationCompensation = mDeviceOrientation
+                    + Util.getDisplayRotation(PanoramaActivity.this);
+            if (mOrientationCompensation != orientationCompensation) {
+                mOrientationCompensation = orientationCompensation;
+                setOrientationIndicator(mOrientationCompensation);
+            }
+        }
+    }
+
+    private void setOrientationIndicator(int degree) {
+        if (mSharePopup != null) mSharePopup.setOrientation(degree);
+    }
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        super.onCreateOptionsMenu(menu);
+
+        addBaseMenuItems(menu);
+        return true;
+    }
+
+    @Override
+    public boolean onPrepareOptionsMenu(Menu menu) {
+        super.onPrepareOptionsMenu(menu);
+        // Only show the menu when idle.
+        boolean idle = (mCaptureState == CAPTURE_STATE_VIEWFINDER && !mThreadRunning);
+        for (int i = 0; i < menu.size(); i++) {
+            MenuItem item = menu.getItem(i);
+            item.setVisible(idle);
+            item.setEnabled(idle);
+        }
+
+        return true;
+    }
+
+    private void addBaseMenuItems(Menu menu) {
+        MenuHelper.addSwitchModeMenuItem(menu, ModePicker.MODE_CAMERA, new Runnable() {
+            public void run() {
+                switchToOtherMode(ModePicker.MODE_CAMERA);
+            }
+        });
+        MenuHelper.addSwitchModeMenuItem(menu, ModePicker.MODE_VIDEO, new Runnable() {
+            public void run() {
+                switchToOtherMode(ModePicker.MODE_VIDEO);
+            }
+        });
+    }
+
+    @Override
+    public void onCreate(Bundle icicle) {
+        super.onCreate(icicle);
+
+        Window window = getWindow();
+        Util.enterLightsOutMode(window);
+        Util.initializeScreenBrightness(window, getContentResolver());
+
+        createContentView();
+
+        mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
+        mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE);
+        if (mSensor == null) {
+            mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION);
+        }
+        PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
+        mPartialWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "Panorama");
+
+        mOrientationEventListener = new PanoOrientationEventListener(this);
+
+        mTransformMatrix = new float[16];
+
+        mPreparePreviewString =
+                getResources().getString(R.string.pano_dialog_prepare_preview);
+        mDialogTitle = getResources().getString(R.string.pano_dialog_title);
+        mDialogOkString = getResources().getString(R.string.dialog_ok);
+        mDialogPanoramaFailedString =
+                getResources().getString(R.string.pano_dialog_panorama_failed);
+        mCameraSound = new MediaActionSound();
+
+        mMainHandler = new Handler() {
+            @Override
+            public void handleMessage(Message msg) {
+                switch (msg.what) {
+                    case MSG_LOW_RES_FINAL_MOSAIC_READY:
+                        onBackgroundThreadFinished();
+                        showFinalMosaic((Bitmap) msg.obj);
+                        saveHighResMosaic();
+                        break;
+                    case MSG_RESET_TO_PREVIEW_WITH_THUMBNAIL:
+                        onBackgroundThreadFinished();
+                        // If the activity is paused, save the thumbnail to the file here.
+                        // If not, it will be saved in onPause.
+                        if (mPausing) saveThumbnailToFile();
+                        // Set the thumbnail bitmap here because mThumbnailView must be accessed
+                        // from the UI thread.
+                        updateThumbnailButton();
+
+                        // Share popup may still have the reference to the old thumbnail. Clear it.
+                        mSharePopup = null;
+                        resetToPreview();
+                        break;
+                    case MSG_GENERATE_FINAL_MOSAIC_ERROR:
+                        onBackgroundThreadFinished();
+                        if (mPausing) {
+                            resetToPreview();
+                        } else {
+                            mRotateDialog.showAlertDialog(
+                                    mDialogTitle, mDialogPanoramaFailedString,
+                                    mDialogOkString, new Runnable() {
+                                        @Override
+                                        public void run() {
+                                            resetToPreview();
+                                        }},
+                                    null, null);
+                        }
+                        break;
+                    case MSG_RESET_TO_PREVIEW:
+                        onBackgroundThreadFinished();
+                        resetToPreview();
+                        break;
+                    case MSG_CLEAR_SCREEN_DELAY:
+                        getWindow().clearFlags(WindowManager.LayoutParams.
+                                FLAG_KEEP_SCREEN_ON);
+                        break;
+                }
+                clearMosaicFrameProcessorIfNeeded();
+            }
+        };
+    }
+
+    private void setupCamera() throws CameraHardwareException, CameraDisabledException {
+        openCamera();
+        Parameters parameters = mCameraDevice.getParameters();
+        setupCaptureParams(parameters);
+        configureCamera(parameters);
+    }
+
+    private void releaseCamera() {
+        if (mCameraDevice != null) {
+            mCameraDevice.setPreviewCallbackWithBuffer(null);
+            CameraHolder.instance().release();
+            mCameraDevice = null;
+            mCameraState = PREVIEW_STOPPED;
+        }
+    }
+
+    private void openCamera() throws CameraHardwareException, CameraDisabledException {
+        int backCameraId = CameraHolder.instance().getBackCameraId();
+        mCameraDevice = Util.openCamera(this, backCameraId);
+        mCameraOrientation = Util.getCameraOrientation(backCameraId);
+    }
+
+    private boolean findBestPreviewSize(List<Size> supportedSizes, boolean need4To3,
+            boolean needSmaller) {
+        int pixelsDiff = DEFAULT_CAPTURE_PIXELS;
+        boolean hasFound = false;
+        for (Size size : supportedSizes) {
+            int h = size.height;
+            int w = size.width;
+            // we only want 4:3 format.
+            int d = DEFAULT_CAPTURE_PIXELS - h * w;
+            if (needSmaller && d < 0) { // no bigger preview than 960x720.
+                continue;
+            }
+            if (need4To3 && (h * 4 != w * 3)) {
+                continue;
+            }
+            d = Math.abs(d);
+            if (d < pixelsDiff) {
+                mPreviewWidth = w;
+                mPreviewHeight = h;
+                pixelsDiff = d;
+                hasFound = true;
+            }
+        }
+        return hasFound;
+    }
+
+    private void setupCaptureParams(Parameters parameters) {
+        List<Size> supportedSizes = parameters.getSupportedPreviewSizes();
+        if (!findBestPreviewSize(supportedSizes, true, true)) {
+            Log.w(TAG, "No 4:3 ratio preview size supported.");
+            if (!findBestPreviewSize(supportedSizes, false, true)) {
+                Log.w(TAG, "Can't find a supported preview size smaller than 960x720.");
+                findBestPreviewSize(supportedSizes, false, false);
+            }
+        }
+        Log.v(TAG, "preview h = " + mPreviewHeight + " , w = " + mPreviewWidth);
+        parameters.setPreviewSize(mPreviewWidth, mPreviewHeight);
+
+        List<int[]> frameRates = parameters.getSupportedPreviewFpsRange();
+        int last = frameRates.size() - 1;
+        int minFps = (frameRates.get(last))[Parameters.PREVIEW_FPS_MIN_INDEX];
+        int maxFps = (frameRates.get(last))[Parameters.PREVIEW_FPS_MAX_INDEX];
+        parameters.setPreviewFpsRange(minFps, maxFps);
+        Log.v(TAG, "preview fps: " + minFps + ", " + maxFps);
+
+        List<String> supportedFocusModes = parameters.getSupportedFocusModes();
+        if (supportedFocusModes.indexOf(mTargetFocusMode) >= 0) {
+            parameters.setFocusMode(mTargetFocusMode);
+        } else {
+            // Use the default focus mode and log a message
+            Log.w(TAG, "Cannot set the focus mode to " + mTargetFocusMode +
+                  " becuase the mode is not supported.");
+        }
+
+        parameters.setRecordingHint(false);
+
+        mHorizontalViewAngle = parameters.getHorizontalViewAngle();
+        mVerticalViewAngle =  parameters.getVerticalViewAngle();
+    }
+
+    public int getPreviewBufSize() {
+        PixelFormat pixelInfo = new PixelFormat();
+        PixelFormat.getPixelFormatInfo(mCameraDevice.getParameters().getPreviewFormat(), pixelInfo);
+        // TODO: remove this extra 32 byte after the driver bug is fixed.
+        return (mPreviewWidth * mPreviewHeight * pixelInfo.bitsPerPixel / 8) + 32;
+    }
+
+    private void configureCamera(Parameters parameters) {
+        mCameraDevice.setParameters(parameters);
+    }
+
+    private boolean switchToOtherMode(int mode) {
+        if (isFinishing()) {
+            return false;
+        }
+        MenuHelper.gotoMode(mode, this);
+        finish();
+        return true;
+    }
+
+    public boolean onModeChanged(int mode) {
+        if (mode != ModePicker.MODE_PANORAMA) {
+            return switchToOtherMode(mode);
+        } else {
+            return true;
+        }
+    }
+
+    @Override
+    public void onMosaicSurfaceChanged() {
+        runOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+                // If panorama is generating low res or high res mosaic, it
+                // means users exit and come back to panorama. Do not start the
+                // preview. Preview will be started after final mosaic is
+                // generated.
+                if (!mPausing) {
+                    startCameraPreview();
+                }
+            }
+        });
+    }
+
+    @Override
+    public void onMosaicSurfaceCreated(final int textureID) {
+        runOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+                if (mSurfaceTexture != null) {
+                    mSurfaceTexture.release();
+                }
+                mSurfaceTexture = new SurfaceTexture(textureID);
+                if (!mPausing) {
+                    mSurfaceTexture.setOnFrameAvailableListener(PanoramaActivity.this);
+                }
+            }
+        });
+    }
+
+    public void runViewFinder() {
+        mMosaicView.setWarping(false);
+        // Call preprocess to render it to low-res and high-res RGB textures.
+        mMosaicView.preprocess(mTransformMatrix);
+        mMosaicView.setReady();
+        mMosaicView.requestRender();
+    }
+
+    public void runMosaicCapture() {
+        mMosaicView.setWarping(true);
+        // Call preprocess to render it to low-res and high-res RGB textures.
+        mMosaicView.preprocess(mTransformMatrix);
+        // Lock the conditional variable to ensure the order of transferGPUtoCPU and
+        // mMosaicFrame.processFrame().
+        mMosaicView.lockPreviewReadyFlag();
+        // Now, transfer the textures from GPU to CPU memory for processing
+        mMosaicView.transferGPUtoCPU();
+        // Wait on the condition variable (will be opened when GPU->CPU transfer is done).
+        mMosaicView.waitUntilPreviewReady();
+        mMosaicFrameProcessor.processFrame();
+    }
+
+    public synchronized void onFrameAvailable(SurfaceTexture surface) {
+        /* This function may be called by some random thread,
+         * so let's be safe and use synchronize. No OpenGL calls can be done here.
+         */
+        // Frames might still be available after the activity is paused. If we call onFrameAvailable
+        // after pausing, the GL thread will crash.
+        if (mPausing) return;
+
+        // Updating the texture should be done in the GL thread which mMosaicView is attached.
+        mMosaicView.queueEvent(new Runnable() {
+            @Override
+            public void run() {
+                // Check if the activity is paused here can speed up the onPause() process.
+                if (mPausing) return;
+                mSurfaceTexture.updateTexImage();
+                mSurfaceTexture.getTransformMatrix(mTransformMatrix);
+            }
+        });
+        // Update the transformation matrix for mosaic pre-process.
+        if (mCaptureState == CAPTURE_STATE_VIEWFINDER) {
+            runViewFinder();
+        } else {
+            runMosaicCapture();
+        }
+    }
+
+    private void hideDirectionIndicators() {
+        mLeftIndicator.setVisibility(View.GONE);
+        mRightIndicator.setVisibility(View.GONE);
+    }
+
+    private void showDirectionIndicators(int direction) {
+        switch (direction) {
+            case PanoProgressBar.DIRECTION_NONE:
+                mLeftIndicator.setVisibility(View.VISIBLE);
+                mRightIndicator.setVisibility(View.VISIBLE);
+                break;
+            case PanoProgressBar.DIRECTION_LEFT:
+                mLeftIndicator.setVisibility(View.VISIBLE);
+                mRightIndicator.setVisibility(View.GONE);
+                break;
+            case PanoProgressBar.DIRECTION_RIGHT:
+                mLeftIndicator.setVisibility(View.GONE);
+                mRightIndicator.setVisibility(View.VISIBLE);
+                break;
+        }
+    }
+
+    public void startCapture() {
+        // Reset values so we can do this again.
+        mCancelComputation = false;
+        mTimeTaken = System.currentTimeMillis();
+        mCaptureState = CAPTURE_STATE_MOSAIC;
+        mShutterButton.setBackgroundResource(R.drawable.btn_shutter_pan_recording);
+        mCaptureIndicator.setVisibility(View.VISIBLE);
+        showDirectionIndicators(PanoProgressBar.DIRECTION_NONE);
+        mThumbnailView.setEnabled(false);
+
+        mCompassValueXStart = mCompassValueXStartBuffer;
+        mCompassValueYStart = mCompassValueYStartBuffer;
+        mTimestamp = 0;
+
+        mMosaicFrameProcessor.setProgressListener(new MosaicFrameProcessor.ProgressListener() {
+            @Override
+            public void onProgress(boolean isFinished, float panningRateX, float panningRateY,
+                    float progressX, float progressY) {
+                float accumulatedHorizontalAngle = progressX * mHorizontalViewAngle;
+                float accumulatedVerticalAngle = progressY * mVerticalViewAngle;
+                if (isFinished
+                        || (Math.abs(accumulatedHorizontalAngle) >= DEFAULT_SWEEP_ANGLE)
+                        || (Math.abs(accumulatedVerticalAngle) >= DEFAULT_SWEEP_ANGLE)) {
+                    stopCapture(false);
+                } else {
+                    float panningRateXInDegree = panningRateX * mHorizontalViewAngle;
+                    float panningRateYInDegree = panningRateY * mVerticalViewAngle;
+                    updateProgress(panningRateXInDegree, panningRateYInDegree,
+                            accumulatedHorizontalAngle, accumulatedVerticalAngle);
+                }
+            }
+        });
+
+        if (mModePicker != null) mModePicker.setEnabled(false);
+
+        mPanoProgressBar.reset();
+        // TODO: calculate the indicator width according to different devices to reflect the actual
+        // angle of view of the camera device.
+        mPanoProgressBar.setIndicatorWidth(20);
+        mPanoProgressBar.setMaxProgress(DEFAULT_SWEEP_ANGLE);
+        mPanoProgressBar.setVisibility(View.VISIBLE);
+        mDeviceOrientationAtCapture = mDeviceOrientation;
+        keepScreenOn();
+    }
+
+    private void stopCapture(boolean aborted) {
+        mCaptureState = CAPTURE_STATE_VIEWFINDER;
+        mCaptureIndicator.setVisibility(View.GONE);
+        hideTooFastIndication();
+        hideDirectionIndicators();
+        mThumbnailView.setEnabled(true);
+
+        mMosaicFrameProcessor.setProgressListener(null);
+        stopCameraPreview();
+
+        mSurfaceTexture.setOnFrameAvailableListener(null);
+
+        if (!aborted && !mThreadRunning) {
+            mRotateDialog.showWaitingDialog(mPreparePreviewString);
+            runBackgroundThread(new Thread() {
+                @Override
+                public void run() {
+                    MosaicJpeg jpeg = generateFinalMosaic(false);
+
+                    if (jpeg != null && jpeg.isValid) {
+                        Bitmap bitmap = null;
+                        bitmap = BitmapFactory.decodeByteArray(jpeg.data, 0, jpeg.data.length);
+                        mMainHandler.sendMessage(mMainHandler.obtainMessage(
+                                MSG_LOW_RES_FINAL_MOSAIC_READY, bitmap));
+                    } else {
+                        mMainHandler.sendMessage(mMainHandler.obtainMessage(
+                                MSG_RESET_TO_PREVIEW));
+                    }
+                }
+            });
+        }
+        // do we have to wait for the thread to complete before enabling this?
+        if (mModePicker != null) mModePicker.setEnabled(true);
+        keepScreenOnAwhile();
+    }
+
+    private void showTooFastIndication() {
+        mTooFastPrompt.setVisibility(View.VISIBLE);
+        mFastIndicationBorder.setVisibility(View.VISIBLE);
+        mPanoProgressBar.setIndicatorColor(mIndicatorColorFast);
+        mLeftIndicator.setEnabled(true);
+        mRightIndicator.setEnabled(true);
+    }
+
+    private void hideTooFastIndication() {
+        mTooFastPrompt.setVisibility(View.GONE);
+        mFastIndicationBorder.setVisibility(View.GONE);
+        mPanoProgressBar.setIndicatorColor(mIndicatorColor);
+        mLeftIndicator.setEnabled(false);
+        mRightIndicator.setEnabled(false);
+    }
+
+    private void updateProgress(float panningRateXInDegree, float panningRateYInDegree,
+            float progressHorizontalAngle, float progressVerticalAngle) {
+        mMosaicView.setReady();
+        mMosaicView.requestRender();
+
+        // TODO: Now we just display warning message by the panning speed.
+        // Since we only support horizontal panning, we should display a warning message
+        // in UI when there're significant vertical movements.
+        if ((Math.abs(panningRateXInDegree) > PANNING_SPEED_THRESHOLD)
+            || (Math.abs(panningRateYInDegree) > PANNING_SPEED_THRESHOLD)) {
+            showTooFastIndication();
+        } else {
+            hideTooFastIndication();
+        }
+        int angleInMajorDirection =
+                (Math.abs(progressHorizontalAngle) > Math.abs(progressVerticalAngle))
+                ? (int) progressHorizontalAngle
+                : (int) progressVerticalAngle;
+        mPanoProgressBar.setProgress((angleInMajorDirection));
+    }
+
+    private void createContentView() {
+        setContentView(R.layout.panorama);
+
+        mCaptureState = CAPTURE_STATE_VIEWFINDER;
+
+        Resources appRes = getResources();
+
+        mCaptureLayout = (View) findViewById(R.id.pano_capture_layout);
+        mPanoProgressBar = (PanoProgressBar) findViewById(R.id.pano_pan_progress_bar);
+        mPanoProgressBar.setBackgroundColor(appRes.getColor(R.color.pano_progress_empty));
+        mPanoProgressBar.setDoneColor(appRes.getColor(R.color.pano_progress_done));
+        mIndicatorColor = appRes.getColor(R.color.pano_progress_indication);
+        mIndicatorColorFast = appRes.getColor(R.color.pano_progress_indication_fast);
+        mPanoProgressBar.setIndicatorColor(mIndicatorColor);
+        mPanoProgressBar.setOnDirectionChangeListener(
+                new PanoProgressBar.OnDirectionChangeListener () {
+                    @Override
+                    public void onDirectionChange(int direction) {
+                        if (mCaptureState == CAPTURE_STATE_MOSAIC) {
+                            showDirectionIndicators(direction);
+                        }
+                    }
+                });
+
+        mLeftIndicator = (ImageView) findViewById(R.id.pano_pan_left_indicator);
+        mRightIndicator = (ImageView) findViewById(R.id.pano_pan_right_indicator);
+        mLeftIndicator.setEnabled(false);
+        mRightIndicator.setEnabled(false);
+        mTooFastPrompt = (TextView) findViewById(R.id.pano_capture_too_fast_textview);
+        mFastIndicationBorder = (View) findViewById(R.id.pano_speed_indication_border);
+
+        mSavingProgressBar = (PanoProgressBar) findViewById(R.id.pano_saving_progress_bar);
+        mSavingProgressBar.setIndicatorWidth(0);
+        mSavingProgressBar.setMaxProgress(100);
+        mSavingProgressBar.setBackgroundColor(appRes.getColor(R.color.pano_progress_empty));
+        mSavingProgressBar.setDoneColor(appRes.getColor(R.color.pano_progress_indication));
+
+        mCaptureIndicator = (RotateLayout) findViewById(R.id.pano_capture_indicator);
+
+        mThumbnailView = (RotateImageView) findViewById(R.id.thumbnail);
+        mThumbnailView.enableFilter(false);
+
+        mReviewLayout = (View) findViewById(R.id.pano_review_layout);
+        mReview = (ImageView) findViewById(R.id.pano_reviewarea);
+        mMosaicView = (MosaicRendererSurfaceView) findViewById(R.id.pano_renderer);
+        mMosaicView.getRenderer().setMosaicSurfaceCreateListener(this);
+
+        mModePicker = (ModePicker) findViewById(R.id.mode_picker);
+        mModePicker.setVisibility(View.VISIBLE);
+        mModePicker.setOnModeChangeListener(this);
+        mModePicker.setCurrentMode(ModePicker.MODE_PANORAMA);
+
+        mShutterButton = (ShutterButton) findViewById(R.id.shutter_button);
+        mShutterButton.setBackgroundResource(R.drawable.btn_shutter_pan);
+        mShutterButton.setOnShutterButtonListener(this);
+
+        mPanoLayout = findViewById(R.id.pano_layout);
+
+        mRotateDialog = new RotateDialogController(this, R.layout.rotate_dialog);
+
+        if (getRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_PORTRAIT) {
+            Rotatable[] rotateLayout = {
+                    (Rotatable) findViewById(R.id.pano_pan_progress_bar_layout),
+                    (Rotatable) findViewById(R.id.pano_capture_too_fast_textview_layout),
+                    (Rotatable) findViewById(R.id.pano_review_saving_indication_layout),
+                    (Rotatable) findViewById(R.id.pano_saving_progress_bar_layout),
+                    (Rotatable) findViewById(R.id.pano_review_cancel_button_layout),
+                    (Rotatable) findViewById(R.id.pano_rotate_reviewarea),
+                    (Rotatable) mRotateDialog,
+                    (Rotatable) mCaptureIndicator,
+                    (Rotatable) mModePicker,
+                    (Rotatable) mThumbnailView};
+            for (Rotatable r : rotateLayout) {
+                r.setOrientation(270);
+            }
+        }
+    }
+
+    @Override
+    public void onShutterButtonClick() {
+        // If mSurfaceTexture == null then GL setup is not finished yet.
+        // No buttons can be pressed.
+        if (mPausing || mThreadRunning || mSurfaceTexture == null) return;
+        // Since this button will stay on the screen when capturing, we need to check the state
+        // right now.
+        switch (mCaptureState) {
+            case CAPTURE_STATE_VIEWFINDER:
+                mCameraSound.play(MediaActionSound.START_VIDEO_RECORDING);
+                startCapture();
+                break;
+            case CAPTURE_STATE_MOSAIC:
+                mCameraSound.play(MediaActionSound.STOP_VIDEO_RECORDING);
+                stopCapture(false);
+        }
+    }
+
+    @Override
+    public void onShutterButtonFocus(boolean pressed) {
+    }
+
+    public void reportProgress() {
+        mSavingProgressBar.reset();
+        mSavingProgressBar.setRightIncreasing(true);
+        Thread t = new Thread() {
+            @Override
+            public void run() {
+                while (mThreadRunning) {
+                    final int progress = mMosaicFrameProcessor.reportProgress(
+                            true, mCancelComputation);
+
+                    try {
+                        synchronized (mWaitObject) {
+                            mWaitObject.wait(50);
+                        }
+                    } catch (InterruptedException e) {
+                        throw new RuntimeException("Panorama reportProgress failed", e);
+                    }
+                    // Update the progress bar
+                    runOnUiThread(new Runnable() {
+                        public void run() {
+                            mSavingProgressBar.setProgress(progress);
+                        }
+                    });
+                }
+            }
+        };
+        t.start();
+    }
+
+    private void initThumbnailButton() {
+        // Load the thumbnail from the disk.
+        if (mThumbnail == null) {
+            mThumbnail = Thumbnail.loadFrom(new File(getFilesDir(), Thumbnail.LAST_THUMB_FILENAME));
+        }
+        updateThumbnailButton();
+    }
+
+    private void updateThumbnailButton() {
+        // Update last image if URI is invalid and the storage is ready.
+        ContentResolver contentResolver = getContentResolver();
+        if ((mThumbnail == null || !Util.isUriValid(mThumbnail.getUri(), contentResolver))) {
+            mThumbnail = Thumbnail.getLastThumbnail(contentResolver);
+        }
+        if (mThumbnail != null) {
+            mThumbnailView.setBitmap(mThumbnail.getBitmap());
+        } else {
+            mThumbnailView.setBitmap(null);
+        }
+    }
+
+    private void saveThumbnailToFile() {
+        if (mThumbnail != null && !mThumbnail.fromFile()) {
+            mThumbnail.saveTo(new File(getFilesDir(), Thumbnail.LAST_THUMB_FILENAME));
+        }
+    }
+
+    public void saveHighResMosaic() {
+        runBackgroundThread(new Thread() {
+            @Override
+            public void run() {
+                mPartialWakeLock.acquire();
+                MosaicJpeg jpeg;
+                try {
+                    jpeg = generateFinalMosaic(true);
+                } finally {
+                    mPartialWakeLock.release();
+                }
+
+                if (jpeg == null) {  // Cancelled by user.
+                    mMainHandler.sendEmptyMessage(MSG_RESET_TO_PREVIEW);
+                } else if (!jpeg.isValid) {  // Error when generating mosaic.
+                    mMainHandler.sendEmptyMessage(MSG_GENERATE_FINAL_MOSAIC_ERROR);
+                } else {
+                    // The panorama image returned from the library is orientated based on the
+                    // natural orientation of a camera. We need to set an orientation for the image
+                    // in its EXIF header, so the image can be displayed correctly.
+                    // The orientation is calculated from compensating the
+                    // device orientation at capture and the camera orientation respective to
+                    // the natural orientation of the device.
+                    int orientation = (mDeviceOrientationAtCapture + mCameraOrientation) % 360;
+                    Uri uri = savePanorama(jpeg.data, jpeg.width, jpeg.height, orientation);
+                    if (uri != null) {
+                        // Create a thumbnail whose width or height is equal or bigger
+                        // than the screen's width or height.
+                        int widthRatio = (int) Math.ceil((double) jpeg.width
+                                / mPanoLayout.getWidth());
+                        int heightRatio = (int) Math.ceil((double) jpeg.height
+                                / mPanoLayout.getHeight());
+                        int inSampleSize = Integer.highestOneBit(
+                                Math.max(widthRatio, heightRatio));
+                        mThumbnail = Thumbnail.createThumbnail(
+                                jpeg.data, orientation, inSampleSize, uri);
+                        Util.broadcastNewPicture(PanoramaActivity.this, uri);
+                    }
+                    mMainHandler.sendMessage(
+                            mMainHandler.obtainMessage(MSG_RESET_TO_PREVIEW_WITH_THUMBNAIL));
+                }
+            }
+        });
+        reportProgress();
+    }
+
+    private void runBackgroundThread(Thread thread) {
+        mThreadRunning = true;
+        thread.start();
+    }
+
+    private void onBackgroundThreadFinished() {
+        mThreadRunning = false;
+        mRotateDialog.dismissDialog();
+    }
+
+    private void cancelHighResComputation() {
+        mCancelComputation = true;
+        synchronized (mWaitObject) {
+            mWaitObject.notify();
+        }
+    }
+
+    @OnClickAttr
+    public void onCancelButtonClicked(View v) {
+        if (mPausing || mSurfaceTexture == null) return;
+        cancelHighResComputation();
+    }
+
+    @OnClickAttr
+    public void onThumbnailClicked(View v) {
+        if (mPausing || mThreadRunning || mSurfaceTexture == null) return;
+        showSharePopup();
+    }
+
+    private void showSharePopup() {
+        if (mThumbnail == null) return;
+        Uri uri = mThumbnail.getUri();
+        if (mSharePopup == null || !uri.equals(mSharePopup.getUri())) {
+            // The orientation compensation is set to 0 here because we only support landscape.
+            mSharePopup = new SharePopup(this, uri, mThumbnail.getBitmap(),
+                    mOrientationCompensation,
+                    findViewById(R.id.frame_layout));
+        }
+        mSharePopup.showAtLocation(mThumbnailView, Gravity.NO_GRAVITY, 0, 0);
+    }
+
+    private void reset() {
+        mCaptureState = CAPTURE_STATE_VIEWFINDER;
+
+        mReviewLayout.setVisibility(View.GONE);
+        mShutterButton.setBackgroundResource(R.drawable.btn_shutter_pan);
+        mPanoProgressBar.setVisibility(View.GONE);
+        mCaptureLayout.setVisibility(View.VISIBLE);
+        mMosaicFrameProcessor.reset();
+
+        mSurfaceTexture.setOnFrameAvailableListener(this);
+    }
+
+    private void resetToPreview() {
+        reset();
+        if (!mPausing) {
+           mMosaicView.onPause();
+           mMosaicView.onResume();
+           startCameraPreview();
+        }
+    }
+
+    private void showFinalMosaic(Bitmap bitmap) {
+        if (bitmap != null) {
+            mReview.setImageBitmap(bitmap);
+        }
+        mCaptureLayout.setVisibility(View.GONE);
+        mReviewLayout.setVisibility(View.VISIBLE);
+    }
+
+    private Uri savePanorama(byte[] jpegData, int width, int height, int orientation) {
+        if (jpegData != null) {
+            String filename = PanoUtil.createName(
+                    getResources().getString(R.string.pano_file_name_format), mTimeTaken);
+            Uri uri = Storage.addImage(getContentResolver(), filename, mTimeTaken, null,
+                    orientation, jpegData, width, height);
+            if (uri != null && orientation != 0) {
+                String filepath = Storage.generateFilepath(filename);
+                try {
+                    // Save the orientation in EXIF.
+                    ExifInterface exif = new ExifInterface(filepath);
+                    exif.setAttribute(ExifInterface.TAG_ORIENTATION,
+                            getExifOrientation(orientation));
+                    exif.saveAttributes();
+                } catch (IOException e) {
+                    Log.e(TAG, "cannot set exif data: " + filepath);
+                }
+            }
+            return uri;
+        }
+        return null;
+    }
+
+    private static String getExifOrientation(int orientation) {
+        switch (orientation) {
+            case 0:
+                return String.valueOf(ExifInterface.ORIENTATION_NORMAL);
+            case 90:
+                return String.valueOf(ExifInterface.ORIENTATION_ROTATE_90);
+            case 180:
+                return String.valueOf(ExifInterface.ORIENTATION_ROTATE_180);
+            case 270:
+                return String.valueOf(ExifInterface.ORIENTATION_ROTATE_270);
+            default:
+                throw new AssertionError("invalid: " + orientation);
+        }
+    }
+
+    private void clearMosaicFrameProcessorIfNeeded() {
+        if (!mPausing || mThreadRunning) return;
+        mMosaicFrameProcessor.clear();
+    }
+
+    private void initMosaicFrameProcessorIfNeeded() {
+        if (mPausing || mThreadRunning) return;
+        if (mMosaicFrameProcessor == null) {
+            // Start the activity for the first time.
+            mMosaicFrameProcessor = new MosaicFrameProcessor(
+                    mPreviewWidth, mPreviewHeight, getPreviewBufSize());
+        }
+        mMosaicFrameProcessor.initialize();
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+
+        mPausing = true;
+        // Stop the capturing first.
+        if (mCaptureState == CAPTURE_STATE_MOSAIC) {
+            stopCapture(true);
+            reset();
+        }
+        if (mSharePopup != null) mSharePopup.dismiss();
+
+        saveThumbnailToFile();
+
+        releaseCamera();
+        mMosaicView.onPause();
+        clearMosaicFrameProcessorIfNeeded();
+        mOrientationEventListener.disable();
+        resetScreenOn();
+        mCameraSound.release();
+        System.gc();
+    }
+
+    @Override
+    protected void doOnResume() {
+        mPausing = false;
+        mOrientationEventListener.enable();
+
+        mCaptureState = CAPTURE_STATE_VIEWFINDER;
+        try {
+            setupCamera();
+
+            // Camera must be initialized before MosaicFrameProcessor is initialized.
+            // The preview size has to be decided by camera device.
+            initMosaicFrameProcessorIfNeeded();
+            mMosaicView.onResume();
+
+            initThumbnailButton();
+            keepScreenOnAwhile();
+        } catch (CameraHardwareException e) {
+            Util.showErrorAndFinish(this, R.string.cannot_connect_camera);
+            return;
+        } catch (CameraDisabledException e) {
+            Util.showErrorAndFinish(this, R.string.camera_disabled);
+            return;
+        }
+        // Dismiss open menu if exists.
+        PopupManager.getInstance(this).notifyShowPopup(null);
+    }
+
+    /**
+     * Generate the final mosaic image.
+     *
+     * @param highRes flag to indicate whether we want to get a high-res version.
+     * @return a MosaicJpeg with its isValid flag set to true if successful; null if the generation
+     *         process is cancelled; and a MosaicJpeg with its isValid flag set to false if there
+     *         is an error in generating the final mosaic.
+     */
+    public MosaicJpeg generateFinalMosaic(boolean highRes) {
+        int mosaicReturnCode = mMosaicFrameProcessor.createMosaic(highRes);
+        if (mosaicReturnCode == Mosaic.MOSAIC_RET_CANCELLED) {
+            return null;
+        } else if (mosaicReturnCode == Mosaic.MOSAIC_RET_ERROR) {
+            return new MosaicJpeg();
+        }
+
+        byte[] imageData = mMosaicFrameProcessor.getFinalMosaicNV21();
+        if (imageData == null) {
+            Log.e(TAG, "getFinalMosaicNV21() returned null.");
+            return new MosaicJpeg();
+        }
+
+        int len = imageData.length - 8;
+        int width = (imageData[len + 0] << 24) + ((imageData[len + 1] & 0xFF) << 16)
+                + ((imageData[len + 2] & 0xFF) << 8) + (imageData[len + 3] & 0xFF);
+        int height = (imageData[len + 4] << 24) + ((imageData[len + 5] & 0xFF) << 16)
+                + ((imageData[len + 6] & 0xFF) << 8) + (imageData[len + 7] & 0xFF);
+        Log.v(TAG, "ImLength = " + (len) + ", W = " + width + ", H = " + height);
+
+        if (width <= 0 || height <= 0) {
+            // TODO: pop up a error meesage indicating that the final result is not generated.
+            Log.e(TAG, "width|height <= 0!!, len = " + (len) + ", W = " + width + ", H = " +
+                    height);
+            return new MosaicJpeg();
+        }
+
+        YuvImage yuvimage = new YuvImage(imageData, ImageFormat.NV21, width, height, null);
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        yuvimage.compressToJpeg(new Rect(0, 0, width, height), 100, out);
+        try {
+            out.close();
+        } catch (Exception e) {
+            Log.e(TAG, "Exception in storing final mosaic", e);
+            return new MosaicJpeg();
+        }
+        return new MosaicJpeg(out.toByteArray(), width, height);
+    }
+
+    private void setPreviewTexture(SurfaceTexture surface) {
+        try {
+            mCameraDevice.setPreviewTexture(surface);
+        } catch (Throwable ex) {
+            releaseCamera();
+            throw new RuntimeException("setPreviewTexture failed", ex);
+        }
+    }
+
+    private void startCameraPreview() {
+        // If we're previewing already, stop the preview first (this will blank
+        // the screen).
+        if (mCameraState != PREVIEW_STOPPED) stopCameraPreview();
+
+        // Set the display orientation to 0, so that the underlying mosaic library
+        // can always get undistorted mPreviewWidth x mPreviewHeight image data
+        // from SurfaceTexture.
+        mCameraDevice.setDisplayOrientation(0);
+
+        setPreviewTexture(mSurfaceTexture);
+
+        try {
+            Log.v(TAG, "startPreview");
+            mCameraDevice.startPreview();
+        } catch (Throwable ex) {
+            releaseCamera();
+            throw new RuntimeException("startPreview failed", ex);
+        }
+        mCameraState = PREVIEW_ACTIVE;
+    }
+
+    private void stopCameraPreview() {
+        if (mCameraDevice != null && mCameraState != PREVIEW_STOPPED) {
+            Log.v(TAG, "stopPreview");
+            mCameraDevice.stopPreview();
+        }
+        mCameraState = PREVIEW_STOPPED;
+    }
+
+    @Override
+    public void onUserInteraction() {
+        super.onUserInteraction();
+        if (mCaptureState != CAPTURE_STATE_MOSAIC) keepScreenOnAwhile();
+    }
+
+    @Override
+    public void onBackPressed() {
+        // If panorama is generating low res or high res mosaic, ignore back
+        // key. So the activity will not be destroyed.
+        if (mThreadRunning) return;
+        super.onBackPressed();
+    }
+
+    private void resetScreenOn() {
+        mMainHandler.removeMessages(MSG_CLEAR_SCREEN_DELAY);
+        getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
+    }
+
+    private void keepScreenOnAwhile() {
+        mMainHandler.removeMessages(MSG_CLEAR_SCREEN_DELAY);
+        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
+        mMainHandler.sendEmptyMessageDelayed(MSG_CLEAR_SCREEN_DELAY, SCREEN_DELAY);
+    }
+
+    private void keepScreenOn() {
+        mMainHandler.removeMessages(MSG_CLEAR_SCREEN_DELAY);
+        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
+    }
+}
diff --git a/src/com/android/camera/panorama/Mosaic.java b/src/com/android/camera/panorama/Mosaic.java
deleted file mode 100644
index 90bf2ad..0000000
--- a/src/com/android/camera/panorama/Mosaic.java
+++ /dev/null
@@ -1,206 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.camera.panorama;
-
-/**
- * The Java interface to JNI calls regarding mosaic stitching.
- *
- * A high-level usage is:
- *
- * Mosaic mosaic = new Mosaic();
- * mosaic.setSourceImageDimensions(width, height);
- * mosaic.reset(blendType);
- *
- * while ((pixels = hasNextImage()) != null) {
- *    mosaic.setSourceImage(pixels);
- * }
- *
- * mosaic.createMosaic(highRes);
- * byte[] result = mosaic.getFinalMosaic();
- *
- */
-public class Mosaic {
-    /**
-     * In this mode, the images are stitched together in the same spatial arrangement as acquired
-     * i.e. if the user follows a curvy trajectory, the image boundary of the resulting mosaic will
-     * be curved in the same manner. This mode is useful if the user wants to capture a mosaic as
-     * if "painting" the scene using the smart-phone device and does not want any corrective warps
-     * to distort the captured images.
-     */
-    public static final int BLENDTYPE_FULL = 0;
-
-    /**
-     * This mode is the same as BLENDTYPE_FULL except that the resulting mosaic is rotated
-     * to balance the first and last images to be approximately at the same vertical offset in the
-     * output mosaic. This is useful when acquiring a mosaic by a typical panning-like motion to
-     * remove a one-sided curve in the mosaic (typically due to the camera not staying horizontal
-     * during the video capture) and convert it to a more symmetrical "smiley-face" like output.
-     */
-    public static final int BLENDTYPE_PAN = 1;
-
-    /**
-     * This mode compensates for typical "smiley-face" like output in longer mosaics and creates
-     * a rectangular mosaic with minimal black borders (by unwrapping the mosaic onto an imaginary
-     * cylinder). If the user follows a curved trajectory (instead of a perfect panning trajectory),
-     * the resulting mosaic here may suffer from some image distortions in trying to map the
-     * trajectory to a cylinder.
-     */
-    public static final int BLENDTYPE_CYLINDERPAN = 2;
-
-    /**
-     * This mode is basically BLENDTYPE_CYLINDERPAN plus doing a rectangle cropping before returning
-     * the mosaic. The mode is useful for making the resulting mosaic have a rectangle shape.
-     */
-    public static final int BLENDTYPE_HORIZONTAL =3;
-
-    /**
-     * This strip type will use the default thin strips where the strips are
-     * spaced according to the image capture rate.
-     */
-    public static final int STRIPTYPE_THIN = 0;
-
-    /**
-     * This strip type will use wider strips for blending. The strip separation
-     * is controlled by a threshold on the native side. Since the strips are
-     * wider, there is an additional cross-fade blending step to make the seam
-     * boundaries smoother. Since this mode uses lesser image frames, it is
-     * computationally more efficient than the thin strip mode.
-     */
-    public static final int STRIPTYPE_WIDE = 1;
-
-    /**
-     * Return flags returned by createMosaic() are one of the following.
-     */
-    public static final int MOSAIC_RET_OK = 1;
-    public static final int MOSAIC_RET_ERROR = -1;
-    public static final int MOSAIC_RET_CANCELLED = -2;
-    public static final int MOSAIC_RET_LOW_TEXTURE = -3;
-    public static final int MOSAIC_RET_FEW_INLIERS = 2;
-
-
-    static {
-        System.loadLibrary("jni_legacymosaic");
-    }
-
-    /**
-     * Allocate memory for the image frames at the given resolution.
-     *
-     * @param width width of the input frames in pixels
-     * @param height height of the input frames in pixels
-     */
-    public native void allocateMosaicMemory(int width, int height);
-
-    /**
-     * Free memory allocated by allocateMosaicMemory.
-     *
-     */
-    public native void freeMosaicMemory();
-
-    /**
-     * Pass the input image frame to the native layer. Each time the a new
-     * source image t is set, the transformation matrix from the first source
-     * image to t is computed and returned.
-     *
-     * @param pixels source image of NV21 format.
-     * @return Float array of length 11; first 9 entries correspond to the 3x3
-     *         transformation matrix between the first frame and the passed frame;
-     *         the 10th entry is the number of the passed frame, where the counting
-     *         starts from 1; and the 11th entry is the returning code, whose value
-     *         is one of those MOSAIC_RET_* returning flags defined above.
-     */
-    public native float[] setSourceImage(byte[] pixels);
-
-    /**
-     * This is an alternative to the setSourceImage function above. This should
-     * be called when the image data is already on the native side in a fixed
-     * byte array. In implementation, this array is filled by the GL thread
-     * using glReadPixels directly from GPU memory (where it is accessed by
-     * an associated SurfaceTexture).
-     *
-     * @return Float array of length 11; first 9 entries correspond to the 3x3
-     *         transformation matrix between the first frame and the passed frame;
-     *         the 10th entry is the number of the passed frame, where the counting
-     *         starts from 1; and the 11th entry is the returning code, whose value
-     *         is one of those MOSAIC_RET_* returning flags defined above.
-     */
-    public native float[] setSourceImageFromGPU();
-
-    /**
-     * Set the type of 
